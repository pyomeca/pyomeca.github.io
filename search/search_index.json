{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Pyomeca is a python library allowing you to carry out a complete biomechanical analysis; in a simple, logical and concise way. Example Pyomeca implements specialized functionalities commonly used in biomechanics. As an example, let's process the electromyographic data contained in this c3d file . You can follow along without installing anything by using our binder server: from pyomeca import Analogs data_path = \"../tests/data/markers_analogs.c3d\" muscles = [ \"Delt_ant\" , \"Delt_med\" , \"Delt_post\" , \"Supra\" , \"Infra\" , \"Subscap\" , ] emg = Analogs . from_c3d ( data_path , suffix_delimiter = \".\" , usecols = muscles ) emg . plot ( x = \"time\" , col = \"channel\" , col_wrap = 3 ) emg_processed = ( emg . meca . band_pass ( order = 2 , cutoff = [ 10 , 425 ]) . meca . center () . meca . abs () . meca . low_pass ( order = 4 , cutoff = 5 , freq = emg . rate ) . meca . normalize () ) emg_processed . plot ( x = \"time\" , col = \"channel\" , col_wrap = 3 ) import matplotlib.pyplot as plt fig , axes = plt . subplots ( ncols = 2 , figsize = ( 10 , 4 )) emg_processed . mean ( \"channel\" ) . plot ( ax = axes [ 0 ]) axes [ 0 ] . set_title ( \"Mean EMG activation\" ) emg_processed . plot . hist ( ax = axes [ 1 ], bins = 50 ) axes [ 1 ] . set_title ( \"EMG activation distribution\" ) Features Signal processing routine commonly used in biomechanics such as filters, normalization, onset detection, outliers detection, derivatives, etc. Common matrix manipulation routines implemented such as getting Euler angles to/from a rototranslation matrix, creating a system of axes, setting a rotation or translation, transpose or inverse, etc. Easy reading and writing interface to common files in biomechanics ( c3d , csv , xlsx , mat , trc , sto , mot ) All of xarray 's awesome features The following illustration shows all of pyomeca's public API. An interactive version is available in the documentation . Installation Pyomeca itself is a pure Python package, but its dependencies are not. The easiest way to get everything installed is to use conda . To install pyomeca with its recommended dependencies using the conda command line tool: conda install -c conda-forge pyomeca Now that you have installed pyomeca, you should be able to import it: import pyomeca Integration with other modules Pyomeca is designed to work well with other libraries that we have developed: pyosim : interface between OpenSim and pyomeca to perform batch musculoskeletal analyses ezc3d : Easy to use C3D reader/writer in C++, Python and Matlab biorbd : C++ interface and add-ons to the Rigid Body Dynamics Library, with Python and Matlab binders. Bug reports & questions Pyomeca is Apache-licensed and the source code is available on GitHub . If any questions or issues come up as you use pyomeca, please get in touch via GitHub issues . We welcome any input, feedback, bug reports, and contributions. Citing Pyomeca If you use pyomeca in your academic work, please consider citing our paper as: @article { Martinez2020 , doi = {10.21105/joss.02431} , url = {https://doi.org/10.21105/joss.02431} , year = {2020} , publisher = {The Open Journal} , volume = {5} , number = {53} , pages = {2431} , author = {Romain Martinez and Benjamin Michaud and Mickael Begon} , title = {`pyomeca`: An Open-Source Framework for Biomechanical Analysis} , journal = {Journal of Open Source Software} } Please consider citing the xarray project, which pyomeca is based on: @article { jors-xarray , title = {Xarray: N-D labeled arrays and datasets in Python} , author = {Joe Hamman and Stephan Hoyer} , year = {2017} , journal = {Journal of Open Research Software} } Contributors Romain Martinez Benjamin Michaud Mickael Begon Jenn Dowling-Medley Ariane Dang Pyomeca is an open-source project created and supported by the S2M lab .","title":"Home"},{"location":"#example","text":"Pyomeca implements specialized functionalities commonly used in biomechanics. As an example, let's process the electromyographic data contained in this c3d file . You can follow along without installing anything by using our binder server: from pyomeca import Analogs data_path = \"../tests/data/markers_analogs.c3d\" muscles = [ \"Delt_ant\" , \"Delt_med\" , \"Delt_post\" , \"Supra\" , \"Infra\" , \"Subscap\" , ] emg = Analogs . from_c3d ( data_path , suffix_delimiter = \".\" , usecols = muscles ) emg . plot ( x = \"time\" , col = \"channel\" , col_wrap = 3 ) emg_processed = ( emg . meca . band_pass ( order = 2 , cutoff = [ 10 , 425 ]) . meca . center () . meca . abs () . meca . low_pass ( order = 4 , cutoff = 5 , freq = emg . rate ) . meca . normalize () ) emg_processed . plot ( x = \"time\" , col = \"channel\" , col_wrap = 3 ) import matplotlib.pyplot as plt fig , axes = plt . subplots ( ncols = 2 , figsize = ( 10 , 4 )) emg_processed . mean ( \"channel\" ) . plot ( ax = axes [ 0 ]) axes [ 0 ] . set_title ( \"Mean EMG activation\" ) emg_processed . plot . hist ( ax = axes [ 1 ], bins = 50 ) axes [ 1 ] . set_title ( \"EMG activation distribution\" )","title":"Example"},{"location":"#features","text":"Signal processing routine commonly used in biomechanics such as filters, normalization, onset detection, outliers detection, derivatives, etc. Common matrix manipulation routines implemented such as getting Euler angles to/from a rototranslation matrix, creating a system of axes, setting a rotation or translation, transpose or inverse, etc. Easy reading and writing interface to common files in biomechanics ( c3d , csv , xlsx , mat , trc , sto , mot ) All of xarray 's awesome features The following illustration shows all of pyomeca's public API. An interactive version is available in the documentation .","title":"Features"},{"location":"#installation","text":"Pyomeca itself is a pure Python package, but its dependencies are not. The easiest way to get everything installed is to use conda . To install pyomeca with its recommended dependencies using the conda command line tool: conda install -c conda-forge pyomeca Now that you have installed pyomeca, you should be able to import it: import pyomeca","title":"Installation"},{"location":"#integration-with-other-modules","text":"Pyomeca is designed to work well with other libraries that we have developed: pyosim : interface between OpenSim and pyomeca to perform batch musculoskeletal analyses ezc3d : Easy to use C3D reader/writer in C++, Python and Matlab biorbd : C++ interface and add-ons to the Rigid Body Dynamics Library, with Python and Matlab binders.","title":"Integration with other modules"},{"location":"#bug-reports-questions","text":"Pyomeca is Apache-licensed and the source code is available on GitHub . If any questions or issues come up as you use pyomeca, please get in touch via GitHub issues . We welcome any input, feedback, bug reports, and contributions.","title":"Bug reports &amp; questions"},{"location":"#citing-pyomeca","text":"If you use pyomeca in your academic work, please consider citing our paper as: @article { Martinez2020 , doi = {10.21105/joss.02431} , url = {https://doi.org/10.21105/joss.02431} , year = {2020} , publisher = {The Open Journal} , volume = {5} , number = {53} , pages = {2431} , author = {Romain Martinez and Benjamin Michaud and Mickael Begon} , title = {`pyomeca`: An Open-Source Framework for Biomechanical Analysis} , journal = {Journal of Open Source Software} } Please consider citing the xarray project, which pyomeca is based on: @article { jors-xarray , title = {Xarray: N-D labeled arrays and datasets in Python} , author = {Joe Hamman and Stephan Hoyer} , year = {2017} , journal = {Journal of Open Research Software} }","title":"Citing Pyomeca"},{"location":"#contributors","text":"Romain Martinez Benjamin Michaud Mickael Begon Jenn Dowling-Medley Ariane Dang Pyomeca is an open-source project created and supported by the S2M lab .","title":"Contributors"},{"location":"about/","text":"Licence Pyomeca is Apache-licensed and the source code is available on GitHub . Citing Pyomeca If you use pyomeca in your academic work, please consider citing our paper as: @article { Martinez2020 , doi = {10.21105/joss.02431} , url = {https://doi.org/10.21105/joss.02431} , year = {2020} , publisher = {The Open Journal} , volume = {5} , number = {53} , pages = {2431} , author = {Romain Martinez and Benjamin Michaud and Mickael Begon} , title = {`pyomeca`: An Open-Source Framework for Biomechanical Analysis} , journal = {Journal of Open Source Software} } Please consider citing the xarray project, which pyomeca is based on: @article { jors-xarray , title = {Xarray: N-D labeled arrays and datasets in Python} , author = {Joe Hamman and Stephan Hoyer} , year = {2017} , journal = {Journal of Open Research Software} } Papers using Pyomeca Martinez Romain, Benjamin Michaud, Mickael Begon. 2020. \u201c pyomeca : An Open-Source Framework for Biomechanical Analysis \u201d Journal of Open Source Software. Assila Najoua, Claudio Pizzolato, Romain Martinez, David Lloyd, Mickael Begon. 2020. \u201c EMG-Assisted Algorithm to Account for Shoulder Muscles Co-Contraction in Overhead Manual Handling. \u201d Applied Sciences. Martinez, Romain, Najoua Assila, Etienne Goubault, and Micka\u00ebl Begon. 2020. \u201c Sex Differences in Upper Limb Musculoskeletal Biomechanics during a Lifting Task. \u201d Applied Ergonomics 86 (July): 103106. doi:10.1016/j.apergo.2020.103106. Blache, Yoann, Romain Martinez, Rapha\u00ebl Dumas, Mickael Begon, Nicola Hagemeister, and Sonia Duprey. 2019. \u201c Chapter 20 - Motion Analysis and Modeling of the Shoulder: Challenges and Potential Applications. \u201d In DHM and Posturography, edited by Sofia Scataglini and Gunther Paul, 261\u2013271. Academic Press. doi:10.1016/B978-0-12-816713-7.00020-9. Bouffard, Jason, Romain Martinez, Andr\u00e9 Plamondon, Julie N. C\u00f4t\u00e9, and Micka\u00ebl Begon. 2019. \u201c Sex Differences in Glenohumeral Muscle Activation and Coactivation during a Box Lifting Task. \u201d Ergonomics 62 (10). Taylor & Francis: 1327\u20131338. doi:10.1080/00140139.2019.1640396. Martinez, Romain, Jason Bouffard, Benjamin Michaud, Andr\u00e9 Plamondon, Julie N. C\u00f4t\u00e9, and Micka\u00ebl Begon. 2019. \u201c Sex Differences in Upper Limb 3D Joint Contributions during a Lifting Task. \u201d Ergonomics 62 (5): 682\u2013693. doi:10.1080/00140139.2019.1571245. Contributors and support Romain Martinez Benjamin Michaud Micka\u00ebl Begon Jenn Dowling-Medley Ariane Dang Pyomeca is an open-source project created and supported by the S2M lab .","title":"About"},{"location":"about/#licence","text":"Pyomeca is Apache-licensed and the source code is available on GitHub .","title":"Licence"},{"location":"about/#citing-pyomeca","text":"If you use pyomeca in your academic work, please consider citing our paper as: @article { Martinez2020 , doi = {10.21105/joss.02431} , url = {https://doi.org/10.21105/joss.02431} , year = {2020} , publisher = {The Open Journal} , volume = {5} , number = {53} , pages = {2431} , author = {Romain Martinez and Benjamin Michaud and Mickael Begon} , title = {`pyomeca`: An Open-Source Framework for Biomechanical Analysis} , journal = {Journal of Open Source Software} } Please consider citing the xarray project, which pyomeca is based on: @article { jors-xarray , title = {Xarray: N-D labeled arrays and datasets in Python} , author = {Joe Hamman and Stephan Hoyer} , year = {2017} , journal = {Journal of Open Research Software} }","title":"Citing Pyomeca"},{"location":"about/#papers-using-pyomeca","text":"Martinez Romain, Benjamin Michaud, Mickael Begon. 2020. \u201c pyomeca : An Open-Source Framework for Biomechanical Analysis \u201d Journal of Open Source Software. Assila Najoua, Claudio Pizzolato, Romain Martinez, David Lloyd, Mickael Begon. 2020. \u201c EMG-Assisted Algorithm to Account for Shoulder Muscles Co-Contraction in Overhead Manual Handling. \u201d Applied Sciences. Martinez, Romain, Najoua Assila, Etienne Goubault, and Micka\u00ebl Begon. 2020. \u201c Sex Differences in Upper Limb Musculoskeletal Biomechanics during a Lifting Task. \u201d Applied Ergonomics 86 (July): 103106. doi:10.1016/j.apergo.2020.103106. Blache, Yoann, Romain Martinez, Rapha\u00ebl Dumas, Mickael Begon, Nicola Hagemeister, and Sonia Duprey. 2019. \u201c Chapter 20 - Motion Analysis and Modeling of the Shoulder: Challenges and Potential Applications. \u201d In DHM and Posturography, edited by Sofia Scataglini and Gunther Paul, 261\u2013271. Academic Press. doi:10.1016/B978-0-12-816713-7.00020-9. Bouffard, Jason, Romain Martinez, Andr\u00e9 Plamondon, Julie N. C\u00f4t\u00e9, and Micka\u00ebl Begon. 2019. \u201c Sex Differences in Glenohumeral Muscle Activation and Coactivation during a Box Lifting Task. \u201d Ergonomics 62 (10). Taylor & Francis: 1327\u20131338. doi:10.1080/00140139.2019.1640396. Martinez, Romain, Jason Bouffard, Benjamin Michaud, Andr\u00e9 Plamondon, Julie N. C\u00f4t\u00e9, and Micka\u00ebl Begon. 2019. \u201c Sex Differences in Upper Limb 3D Joint Contributions during a Lifting Task. \u201d Ergonomics 62 (5): 682\u2013693. doi:10.1080/00140139.2019.1571245.","title":"Papers using Pyomeca"},{"location":"about/#contributors-and-support","text":"Romain Martinez Benjamin Michaud Micka\u00ebl Begon Jenn Dowling-Medley Ariane Dang Pyomeca is an open-source project created and supported by the S2M lab .","title":"Contributors and support"},{"location":"contributing/","text":"All contributions, bug reports, bug fixes, documentation improvements, enhancements, and ideas are welcome. We recommend going through the issues to find issues that interest you. Then, you can get your development environment setup with the following instructions. Forking Pyomeca You will need your own fork to work on the code. Go to the pyomeca project page and hit the Fork button. You will want to clone your fork to your machine: git clone https://github.com/your-user-name/pyomeca.git cd pyomeca git remote add upstream https://github.com/pyomeca/pyomeca.git Creating a Python environment Before starting any development, you\u2019ll need to create an isolated pyomeca development environment: Install miniconda cd to the pyomeca source directory Install pyomeca dependencies with: conda env create conda activate pyomeca pip install -r requirements-dev.txt Creating a branch You want your master branch to reflect only production-ready code, so create a feature branch for making your changes. For example: git branch -b new-feature Keep any changes in this branch specific to one bug or feature so it is clear what the branch brings to pyomeca. Testing your code Adding tests is required if you add or modify existing codes in pyomeca. Therefore, it is worth getting in the habit of writing tests ahead of time so this is never an issue. The pyomeca test suite runs automatically on GitHub Actions, once your pull request is submitted. However, we strongly encourage running the tests prior to submitting the pull request. To do so, run make test or simply pytest tests . Linting your code Pyomeca uses several tools to ensure a consistent code format throughout the project. The easiest way to use them is to run make lint from the source directory. Making the pull-request When you want your changes to appear publicly on your GitHub page, push your forked feature branch\u2019s commits: git push origin new-feature If everything looks good, you are ready to make a pull request. This pull request and its associated changes will eventually be committed to the master branch and available in the next release. Navigate to your repository on GitHub Click on the Pull Request button You can then click on Files Changed to make sure everything looks OK Write a description of your changes in the Discussion tab Click Send Pull Request This request then goes to the repository maintainers, and they will review the code. If you need to make more changes, you can make them in your branch, add them to a new commit and push them to GitHub. The pull request will be automatically updated. PR Checklist Let's summarize the steps needed to get your PR ready for submission. Use an isolated Python environment . Properly test your code . Write new tests if needed and make sure that your modification didn't break anything by running make test . Properly format your code . You can verify that it passes the formatting guidelines by running make lint . Push your code and create a PR . Properly describe your modifications with a helpful title and description. If this addresses an issue, please reference it.","title":"Contributing"},{"location":"contributing/#forking-pyomeca","text":"You will need your own fork to work on the code. Go to the pyomeca project page and hit the Fork button. You will want to clone your fork to your machine: git clone https://github.com/your-user-name/pyomeca.git cd pyomeca git remote add upstream https://github.com/pyomeca/pyomeca.git","title":"Forking Pyomeca"},{"location":"contributing/#creating-a-python-environment","text":"Before starting any development, you\u2019ll need to create an isolated pyomeca development environment: Install miniconda cd to the pyomeca source directory Install pyomeca dependencies with: conda env create conda activate pyomeca pip install -r requirements-dev.txt","title":"Creating a Python environment"},{"location":"contributing/#creating-a-branch","text":"You want your master branch to reflect only production-ready code, so create a feature branch for making your changes. For example: git branch -b new-feature Keep any changes in this branch specific to one bug or feature so it is clear what the branch brings to pyomeca.","title":"Creating a branch"},{"location":"contributing/#testing-your-code","text":"Adding tests is required if you add or modify existing codes in pyomeca. Therefore, it is worth getting in the habit of writing tests ahead of time so this is never an issue. The pyomeca test suite runs automatically on GitHub Actions, once your pull request is submitted. However, we strongly encourage running the tests prior to submitting the pull request. To do so, run make test or simply pytest tests .","title":"Testing your code"},{"location":"contributing/#linting-your-code","text":"Pyomeca uses several tools to ensure a consistent code format throughout the project. The easiest way to use them is to run make lint from the source directory.","title":"Linting your code"},{"location":"contributing/#making-the-pull-request","text":"When you want your changes to appear publicly on your GitHub page, push your forked feature branch\u2019s commits: git push origin new-feature If everything looks good, you are ready to make a pull request. This pull request and its associated changes will eventually be committed to the master branch and available in the next release. Navigate to your repository on GitHub Click on the Pull Request button You can then click on Files Changed to make sure everything looks OK Write a description of your changes in the Discussion tab Click Send Pull Request This request then goes to the repository maintainers, and they will review the code. If you need to make more changes, you can make them in your branch, add them to a new commit and push them to GitHub. The pull request will be automatically updated. PR Checklist Let's summarize the steps needed to get your PR ready for submission. Use an isolated Python environment . Properly test your code . Write new tests if needed and make sure that your modification didn't break anything by running make test . Properly format your code . You can verify that it passes the formatting guidelines by running make lint . Push your code and create a PR . Properly describe your modifications with a helpful title and description. If this addresses an issue, please reference it.","title":"Making the pull-request"},{"location":"data-processing/","text":"Pyomeca's main functionality is to offer dedicated biomechanical routines. These features can be broadly grouped into different categories: filtering, normalization, matrix manipulation, signal processing and file output functions. Filters Biomechanical data are inherently noisy. And with noise, you will probably need filters. Pyomeca implements the major types of Butterworth filters used in biomechanics. Example Band pass /api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.band_pass Band stop /api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.band_stop High pass /api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.high_pass Low pass /api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.low_pass Normalization It is common to use normalization procedures during biomechanical signal processing. Pyomeca supports two types of normalization: signal normalization and time normalization. Example Signal normalization /api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.normalize Time normalization /api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.time_normalize Matrix manipulation The processing of biomechanical data often involves the use of matrix manipulation routines. Some of them are implemented in Pyomeca. Example Absolute value /api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.abs Center signal /api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.center Matmul /api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.matmul Norm /api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.norm RMS /api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.rms Square /api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.square Square root /api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.sqrt Signal processing Pyomeca implements convenient and flexible functions to detect onsets and outliers, as well as to compute a Fourier Transform. Example Onsets detection /api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.detect_onset Outliers detection /api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.detect_outliers FFT /api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.fft File output While the netcdf format is the preferred file format for saving or sharing data structures, Pyomeca also supports writting csv and matlab files. If you need more flexibility, the to_wide_dataframe method will allow you to use the pandas library to export your data in almost any existing formats. Example Write csv file /api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.to_csv Write matlab file /api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.to_matlab Create wide pandas dataframe /api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.to_wide_dataframe renderApiTemplate()","title":"Data processing"},{"location":"data-processing/#filters","text":"Biomechanical data are inherently noisy. And with noise, you will probably need filters. Pyomeca implements the major types of Butterworth filters used in biomechanics. Example Band pass /api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.band_pass Band stop /api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.band_stop High pass /api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.high_pass Low pass /api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.low_pass","title":"Filters"},{"location":"data-processing/#normalization","text":"It is common to use normalization procedures during biomechanical signal processing. Pyomeca supports two types of normalization: signal normalization and time normalization. Example Signal normalization /api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.normalize Time normalization /api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.time_normalize","title":"Normalization"},{"location":"data-processing/#matrix-manipulation","text":"The processing of biomechanical data often involves the use of matrix manipulation routines. Some of them are implemented in Pyomeca. Example Absolute value /api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.abs Center signal /api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.center Matmul /api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.matmul Norm /api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.norm RMS /api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.rms Square /api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.square Square root /api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.sqrt","title":"Matrix manipulation"},{"location":"data-processing/#signal-processing","text":"Pyomeca implements convenient and flexible functions to detect onsets and outliers, as well as to compute a Fourier Transform. Example Onsets detection /api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.detect_onset Outliers detection /api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.detect_outliers FFT /api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.fft","title":"Signal processing"},{"location":"data-processing/#file-output","text":"While the netcdf format is the preferred file format for saving or sharing data structures, Pyomeca also supports writting csv and matlab files. If you need more flexibility, the to_wide_dataframe method will allow you to use the pandas library to export your data in almost any existing formats. Example Write csv file /api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.to_csv Write matlab file /api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.to_matlab Create wide pandas dataframe /api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.to_wide_dataframe renderApiTemplate()","title":"File output"},{"location":"getting-started/","text":"Installation Before you can use pyomeca, you will need to get it installed. Pyomeca itself is a pure Python package, but its dependencies are not. The easiest way to get everything installed is to use conda . To install pyomeca with its recommended dependencies using the conda command line tool: conda install -c conda-forge pyomeca Now that you have installed pyomeca, you should be able to import it: import pyomeca Note Want to test pyomeca from your browser and without installing anything? Try out our binder server: Quick overview Here is a short introduction to xarray and pyomeca, geared mainly for new users. You should be able to follow along and complete this short example in about 10 minutes. We will carry out common tasks in biomechanics, including reading files, manipulating and processing data, making figures and writing files. Object creation Let's begin by creating a biomechanical data structure with pyomeca. In this tutorial, we will analyze the skin marker data available in this c3d file . Pyomeca provides the from_c3d function to read c3d files. As we want to analyse markers data, we will use the Markers class: from pyomeca import Markers data_path = \"../tests/data/markers_analogs.c3d\" markers = Markers . from_c3d ( data_path , prefix_delimiter = \":\" ) Make sure to always have a check on the data after reading it. When used in Jupyter notebooks , data can be explored interactively. A standard text representation is available otherwise. markers Show/Hide data repr Show/Hide attributes /* CSS stylesheet for displaying xarray objects in jupyterlab. * */ :root { --xr-font-color0: var(--jp-content-font-color0, rgba(0, 0, 0, 1)); --xr-font-color2: var(--jp-content-font-color2, rgba(0, 0, 0, 0.54)); --xr-font-color3: var(--jp-content-font-color3, rgba(0, 0, 0, 0.38)); --xr-border-color: var(--jp-border-color2, #e0e0e0); --xr-disabled-color: var(--jp-layout-color3, #bdbdbd); --xr-background-color: var(--jp-layout-color0, white); --xr-background-color-row-even: var(--jp-layout-color1, white); --xr-background-color-row-odd: var(--jp-layout-color2, #eeeeee); } .xr-wrap { min-width: 300px; max-width: 700px; } .xr-header { padding-top: 6px; padding-bottom: 6px; margin-bottom: 4px; border-bottom: solid 1px var(--xr-border-color); } .xr-header > div, .xr-header > ul { display: inline; margin-top: 0; margin-bottom: 0; } .xr-obj-type, .xr-array-name { margin-left: 2px; margin-right: 10px; } .xr-obj-type { color: var(--xr-font-color2); } .xr-sections { padding-left: 0 !important; display: grid; grid-template-columns: 150px auto auto 1fr 20px 20px; } .xr-section-item { display: contents; } .xr-section-item input { display: none; } .xr-section-item input + label { color: var(--xr-disabled-color); } .xr-section-item input:enabled + label { cursor: pointer; color: var(--xr-font-color2); } .xr-section-item input:enabled + label:hover { color: var(--xr-font-color0); } .xr-section-summary { grid-column: 1; color: var(--xr-font-color2); font-weight: 500; } .xr-section-summary > span { display: inline-block; padding-left: 0.5em; } .xr-section-summary-in:disabled + label { color: var(--xr-font-color2); } .xr-section-summary-in + label:before { display: inline-block; content: '\u25ba'; font-size: 11px; width: 15px; text-align: center; } .xr-section-summary-in:disabled + label:before { color: var(--xr-disabled-color); } .xr-section-summary-in:checked + label:before { content: '\u25bc'; } .xr-section-summary-in:checked + label > span { display: none; } .xr-section-summary, .xr-section-inline-details { padding-top: 4px; padding-bottom: 4px; } .xr-section-inline-details { grid-column: 2 / -1; } .xr-section-details { display: none; grid-column: 1 / -1; margin-bottom: 5px; } .xr-section-summary-in:checked ~ .xr-section-details { display: contents; } .xr-array-wrap { grid-column: 1 / -1; display: grid; grid-template-columns: 20px auto; } .xr-array-wrap > label { grid-column: 1; vertical-align: top; } .xr-preview { color: var(--xr-font-color3); } .xr-array-preview, .xr-array-data { padding: 0 5px !important; grid-column: 2; } .xr-array-data, .xr-array-in:checked ~ .xr-array-preview { display: none; } .xr-array-in:checked ~ .xr-array-data, .xr-array-preview { display: inline-block; } .xr-dim-list { display: inline-block !important; list-style: none; padding: 0 !important; margin: 0; } .xr-dim-list li { display: inline-block; padding: 0; margin: 0; } .xr-dim-list:before { content: '('; } .xr-dim-list:after { content: ')'; } .xr-dim-list li:not(:last-child):after { content: ','; padding-right: 5px; } .xr-has-index { font-weight: bold; } .xr-var-list, .xr-var-item { display: contents; } .xr-var-item > div, .xr-var-item label, .xr-var-item > .xr-var-name span { background-color: var(--xr-background-color-row-even); margin-bottom: 0; } .xr-var-item > .xr-var-name:hover span { padding-right: 5px; } .xr-var-list > li:nth-child(odd) > div, .xr-var-list > li:nth-child(odd) > label, .xr-var-list > li:nth-child(odd) > .xr-var-name span { background-color: var(--xr-background-color-row-odd); } .xr-var-name { grid-column: 1; } .xr-var-dims { grid-column: 2; } .xr-var-dtype { grid-column: 3; text-align: right; color: var(--xr-font-color2); } .xr-var-preview { grid-column: 4; } .xr-var-name, .xr-var-dims, .xr-var-dtype, .xr-preview, .xr-attrs dt { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; padding-right: 10px; } .xr-var-name:hover, .xr-var-dims:hover, .xr-var-dtype:hover, .xr-attrs dt:hover { overflow: visible; width: auto; z-index: 1; } .xr-var-attrs, .xr-var-data { display: none; background-color: var(--xr-background-color) !important; padding-bottom: 5px !important; } .xr-var-attrs-in:checked ~ .xr-var-attrs, .xr-var-data-in:checked ~ .xr-var-data { display: block; } .xr-var-data > table { float: right; } .xr-var-name span, .xr-var-data, .xr-attrs { padding-left: 25px !important; } .xr-attrs, .xr-var-attrs, .xr-var-data { grid-column: 1 / -1; } dl.xr-attrs { padding: 0; margin: 0; display: grid; grid-template-columns: 125px auto; } .xr-attrs dt, dd { padding: 0; margin: 0; float: left; padding-right: 10px; width: auto; } .xr-attrs dt { font-weight: normal; grid-column: 1; } .xr-attrs dt:hover span { display: inline-block; background: var(--xr-background-color); padding-right: 10px; } .xr-attrs dd { grid-column: 2; white-space: pre-wrap; word-break: break-all; } .xr-icon-database, .xr-icon-file-text2 { display: inline-block; vertical-align: middle; width: 1em; height: 1.5em !important; stroke-width: 0; stroke: currentColor; fill: currentColor; } xarray.DataArray 'markers' axis : 4 channel : 51 time : 580 44.16 44.17 44.16 44.17 44.17 44.19 44.2 ... 1.0 1.0 1.0 1.0 1.0 1.0 array([[[ 44.16278839, 44.16666412, 44.16487122, ..., 99.22426605, 99.24201965, 99.25963593], [ 32.57229614, 32.57104111, 32.56489563, ..., 87.51286316, 87.52822876, 87.54118347], [ -93.72181702, -93.72447968, -93.72324371, ..., -41.1590271 , -41.14812851, -41.12734985], ..., [ 562.26068115, 562.41027832, 562.56695557, ..., 625.63555908, 625.98504639, 626.25811768], [ 568.24200439, 568.37792969, 568.49249268, ..., 624.18139648, 624.51190186, 624.78894043], [ 568.44470215, 568.52038574, 568.59216309, ..., 623.09222412, 623.44036865, 623.75152588]], [[-276.86193848, -276.86169434, -276.86407471, ..., -259.15292358, -259.16690063, -259.17092896], [-243.14048767, -243.14073181, -243.13331604, ..., -225.44718933, -225.45556641, -225.46226501], [ 124.78598022, 124.78731537, 124.78870392, ..., 141.820755 , 141.80741882, 141.80308533], ..., [ 638.35144043, 638.4241333 , 638.50653076, ..., 592.00372314, 592.15686035, 592.27819824], [ 626.79144287, 626.86114502, 626.90710449, ..., 584.15661621, 584.27709961, 584.38830566], [ 651.37927246, 651.45532227, 651.49957275, ..., 610.59655762, 610.72821045, 610.84472656]], [[ 675.69683838, 675.69873047, 675.6986084 , ..., 903.97650146, 903.96801758, 903.980896 ], [ 676.57452393, 676.58099365, 676.57720947, ..., 904.61694336, 904.61645508, 904.63104248], [ 674.27874756, 674.27947998, 674.28033447, ..., 902.77349854, 902.77819824, 902.78143311], ..., [ 81.34425354, 81.32899475, 81.2776413 , ..., 53.45215607, 53.57727814, 53.72877121], [ 110.84020996, 110.81329346, 110.76582336, ..., 83.92819214, 84.07093048, 84.20204163], [ 129.69673157, 129.6789856 , 129.62939453, ..., 99.39131165, 99.52735138, 99.68258667]], [[ 1. , 1. , 1. , ..., 1. , 1. , 1. ], [ 1. , 1. , 1. , ..., 1. , 1. , 1. ], [ 1. , 1. , 1. , ..., 1. , 1. , 1. ], ..., [ 1. , 1. , 1. , ..., 1. , 1. , 1. ], [ 1. , 1. , 1. , ..., 1. , 1. , 1. ], [ 1. , 1. , 1. , ..., 1. , 1. , 1. ]]]) Coordinates: (3) axis (axis) <U4 'x' 'y' 'z' 'ones' array(['x', 'y', 'z', 'ones'], dtype='<U4') channel (channel) <U14 'gauche_ext' ... 'LATH' array(['gauche_ext', 'gauche_int', 'droite_int', 'droite_ext', 'avant_gauche', 'avant_droit', 'arriere_droit', 'arriere_gauche', 'ASISr', 'ASISl', 'PSISr', 'PSISl', 'STERr', 'STERl', 'STER', 'XIPH', 'T1', 'T10', 'CLAV_SC', 'CLAVm', 'CLAV_ant', 'CLAV_post', 'CLAVl', 'CLAV_AC', 'ACRO_tip', 'SCAP_AA', 'SCAPl', 'SCAPm', 'SCAP_CP', 'SCAP_RS', 'SCAP_SA', 'SCAP_IA', 'DELT', 'ARMl', 'ARMm', 'ARMp_up', 'ARMp_do', 'EPICl', 'EPICm', 'LARMm', 'LARMl', 'LARM_elb', 'LARM_ant', 'STYLr', 'STYLr_up', 'STYLu', 'WRIST', 'INDEX', 'LASTC', 'MEDH', 'LATH'], dtype='<U14') time (time) float64 0.0 0.01 0.02 ... 5.77 5.78 5.79 array([0. , 0.01, 0.02, ..., 5.77, 5.78, 5.79]) Attributes: (4) first_frame : 0 last_frame : 579 rate : 100.0 units : mm In this case, we have generated a 3D array with the axis , channel and time dimensions. Note There are several ways to create objects in pyomeca: by supplying data, from files or from other data-structure. A more complete guide on object creation is available in the object creation section of the documentation. Indexing Since we have labels associated with each dimension, we have several kinds of indexing available with varying levels of convenience and intuitiveness. Let's see three ways to get the same data (ninth marker and first time frame). Positional indexing Indexing directly works just like it does for numpy arrays. markers [:, 9 , 0 ] <xarray.DataArray 'markers' (axis: 4)> array([753.43908691, 75.9487381 , 187.7590332 , 1. ]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' channel <U14 'ASISl' time float64 0.0 Attributes: first_frame: 0 last_frame: 579 rate: 100.0 units: mm Label-based indexing Label-based indexing frees us from having to know how the data are organized. We do not have to rely on dimension order and can use them explicitly to index the data. The isel method is used when the dimension lookup is by name and the index lookup is by integer markers . isel ( channel = 9 , time = 0 ) <xarray.DataArray 'markers' (axis: 4)> array([753.43908691, 75.9487381 , 187.7590332 , 1. ]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' channel <U14 'ASISl' time float64 0.0 Attributes: first_frame: 0 last_frame: 579 rate: 100.0 units: mm The sel method is used when the dimension and index lookups are both by name. markers . sel ( channel = \"ASISl\" , time = 0 ) <xarray.DataArray 'markers' (axis: 4)> array([753.43908691, 75.9487381 , 187.7590332 , 1. ]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' channel <U14 'ASISl' time float64 0.0 Attributes: first_frame: 0 last_frame: 579 rate: 100.0 units: mm Note xarray offers extremely flexible indexing routines. For more details on indexing see the xarray documentation . Metadata Biomechanical datasets are usually more than just raw numbers and have various metadata attributes. Some metadata are already filled by pyomeca and available in the attrs Python dictionary. markers . attrs >> {'first_frame': 0, 'last_frame': 579, 'rate': 100.0, 'units': 'mm'} They can be accessed using the standard dictionary indexing markers . attrs [ \"rate\" ] >> 100.0 Or directly as a propriety markers . rate >> 100.0 You can assign anything you wish. markers . attrs [ \"description\" ] = \"Skin marker positions recorded in Montreal.\" markers . attrs [ \"participant_id\" ] = 12 markers . time . attrs [ \"units\" ] = \"seconds\" markers <xarray.DataArray 'markers' (axis: 4, channel: 51, time: 580)> array([[[ 44.16278839, 44.16666412, 44.16487122, ..., 99.22426605, 99.24201965, 99.25963593], [ 32.57229614, 32.57104111, 32.56489563, ..., 87.51286316, 87.52822876, 87.54118347], [ -93.72181702, -93.72447968, -93.72324371, ..., -41.1590271 , -41.14812851, -41.12734985], ..., [ 562.26068115, 562.41027832, 562.56695557, ..., 625.63555908, 625.98504639, 626.25811768], [ 568.24200439, 568.37792969, 568.49249268, ..., 624.18139648, 624.51190186, 624.78894043], [ 568.44470215, 568.52038574, 568.59216309, ..., 623.09222412, 623.44036865, 623.75152588]], [[-276.86193848, -276.86169434, -276.86407471, ..., -259.15292358, -259.16690063, -259.17092896], [-243.14048767, -243.14073181, -243.13331604, ..., -225.44718933, -225.45556641, -225.46226501], [ 124.78598022, 124.78731537, 124.78870392, ..., 141.820755 , 141.80741882, 141.80308533], ..., [ 638.35144043, 638.4241333 , 638.50653076, ..., 592.00372314, 592.15686035, 592.27819824], [ 626.79144287, 626.86114502, 626.90710449, ..., 584.15661621, 584.27709961, 584.38830566], [ 651.37927246, 651.45532227, 651.49957275, ..., 610.59655762, 610.72821045, 610.84472656]], [[ 675.69683838, 675.69873047, 675.6986084 , ..., 903.97650146, 903.96801758, 903.980896 ], [ 676.57452393, 676.58099365, 676.57720947, ..., 904.61694336, 904.61645508, 904.63104248], [ 674.27874756, 674.27947998, 674.28033447, ..., 902.77349854, 902.77819824, 902.78143311], ..., [ 81.34425354, 81.32899475, 81.2776413 , ..., 53.45215607, 53.57727814, 53.72877121], [ 110.84020996, 110.81329346, 110.76582336, ..., 83.92819214, 84.07093048, 84.20204163], [ 129.69673157, 129.6789856 , 129.62939453, ..., 99.39131165, 99.52735138, 99.68258667]], [[ 1. , 1. , 1. , ..., 1. , 1. , 1. ], [ 1. , 1. , 1. , ..., 1. , 1. , 1. ], [ 1. , 1. , 1. , ..., 1. , 1. , 1. ], ..., [ 1. , 1. , 1. , ..., 1. , 1. , 1. ], [ 1. , 1. , 1. , ..., 1. , 1. , 1. ], [ 1. , 1. , 1. , ..., 1. , 1. , 1. ]]]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' * channel (channel) <U14 'gauche_ext' 'gauche_int' ... 'MEDH' 'LATH' * time (time) float64 0.0 0.01 0.02 0.03 0.04 ... 5.75 5.76 5.77 5.78 5.79 Attributes: first_frame: 0 last_frame: 579 rate: 100.0 units: mm description: Skin marker positions recorded in Montreal. participant_id: 12 Computation Arithmetic As the underlying data-structure is a numpy array, xarray data arrays work the same way you would expect if you are used to numpy. subset = markers [:, 0 , : 6 ] subset + 10 <xarray.DataArray 'markers' (axis: 4, time: 6)> array([[ 54.16278839, 54.16666412, 54.16487122, 54.16558075, 54.17311096, 54.18517685], [-266.86193848, -266.86169434, -266.86407471, -266.86123657, -266.85812378, -266.85818481], [ 685.69683838, 685.69873047, 685.6986084 , 685.69775391, 685.7041626 , 685.69592285], [ 11. , 11. , 11. , 11. , 11. , 11. ]]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' channel <U14 'gauche_ext' * time (time) float64 0.0 0.01 0.02 0.03 0.04 0.05 subset . T # transpose <xarray.DataArray 'markers' (time: 6, axis: 4)> array([[ 44.16278839, -276.86193848, 675.69683838, 1. ], [ 44.16666412, -276.86169434, 675.69873047, 1. ], [ 44.16487122, -276.86407471, 675.6986084 , 1. ], [ 44.16558075, -276.86123657, 675.69775391, 1. ], [ 44.17311096, -276.85812378, 675.7041626 , 1. ], [ 44.18517685, -276.85818481, 675.69592285, 1. ]]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' channel <U14 'gauche_ext' * time (time) float64 0.0 0.01 0.02 0.03 0.04 0.05 Attributes: first_frame: 0 last_frame: 579 rate: 100.0 units: mm description: Skin marker positions recorded in Montreal. participant_id: 12 subset . mean () <xarray.DataArray 'markers' ()> array(111.00187318) Coordinates: channel <U14 'gauche_ext' subset . mean ( axis = 1 ) <xarray.DataArray 'markers' (axis: 4)> array([ 44.16969872, -276.86087545, 675.69866943, 1. ]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' channel <U14 'gauche_ext' We can, however, take advantage of the labels instead of axis numbers subset . mean ( dim = \"time\" ) <xarray.DataArray 'markers' (axis: 4)> array([ 44.16969872, -276.86087545, 675.69866943, 1. ]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' channel <U14 'gauche_ext' Arithmetic operations broadcast based on dimension name. This means you don\u2019t need to insert dummy dimensions for alignment: only_first_axis = subset . sel ( axis = \"x\" ) only_first_frame = subset . isel ( time = 0 ) only_first_axis <xarray.DataArray 'markers' (time: 6)> array([44.16278839, 44.16666412, 44.16487122, 44.16558075, 44.17311096, 44.18517685]) Coordinates: axis <U4 'x' channel <U14 'gauche_ext' * time (time) float64 0.0 0.01 0.02 0.03 0.04 0.05 Attributes: first_frame: 0 last_frame: 579 rate: 100.0 units: mm description: Skin marker positions recorded in Montreal. participant_id: 12 only_first_frame <xarray.DataArray 'markers' (axis: 4)> array([ 44.16278839, -276.86193848, 675.69683838, 1. ]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' channel <U14 'gauche_ext' time float64 0.0 Attributes: first_frame: 0 last_frame: 579 rate: 100.0 units: mm description: Skin marker positions recorded in Montreal. participant_id: 12 only_first_frame + only_first_axis <xarray.DataArray 'markers' (axis: 4, time: 6)> array([[ 88.32557678, 88.32945251, 88.32765961, 88.32836914, 88.33589935, 88.34796524], [-232.69915009, -232.69527435, -232.69706726, -232.69635773, -232.68882751, -232.67676163], [ 719.85962677, 719.8635025 , 719.86170959, 719.86241913, 719.86994934, 719.88201523], [ 45.16278839, 45.16666412, 45.16487122, 45.16558075, 45.17311096, 45.18517685]]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' channel <U14 'gauche_ext' * time (time) float64 0.0 0.01 0.02 0.03 0.04 0.05 Let's compare with the sum made with numpy arrays: only_first_axis . values + only_first_axis . values >> array([88.32557678, 88.33332825, 88.32974243, 88.3311615 , 88.34622192, 88.3703537 ]) And we do not need to worry about the order of dimensions. subset - subset . T <xarray.DataArray 'markers' (axis: 4, time: 6)> array([[0., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 0., 0.]]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' channel <U14 'gauche_ext' * time (time) float64 0.0 0.01 0.02 0.03 0.04 0.05 Whereas this is not possible with numpy arrays: subset.values - subset.values.T >> ValueError: operands could not be broadcast together with shapes (4,6) (6,4) Note xarray supports powerful shortcuts for computation. For more, see the xarray documentation . Application: exploring missing values When we visualize some of our markers, we can realize that there are some missing values. markers . sel ( axis = \"x\" , channel = \"SCAP_CP\" ) . plot . line ( x = \"time\" ) Let's investigate those missing values markers_null_values = markers . sel ( axis = \"x\" ) . isnull () print ( f \"There are { markers_null_values . sum () . values } missing values\" ) >> There are 305 missing values What are the 5 markers with the most missing values? markers_null_values . sum ( dim = \"time\" ) . to_series () . nlargest ( 5 ) . plot . barh () The cumulative number of missing values can tell us when marker occlusions occur. markers_null_values . sum ( \"channel\" ) . cumsum ( \"time\" ) . plot () Now that we know more about the missing values, we can use xarray for filling missing values via 1D interpolation. markers_without_null = markers . interpolate_na ( dim = \"time\" , method = \"cubic\" ) Now, let's visualize our interpolated markers. import matplotlib.pyplot as plt markers . sel ( axis = \"x\" , channel = \"SCAP_CP\" ) . plot . line ( x = \"time\" ) ( markers_without_null . where ( markers . isnull ()) . sel ( axis = \"x\" , channel = \"SCAP_CP\" ) . plot . line ( x = \"time\" , label = \"interpolated\" , color = \"r\" ) ) plt . legend () ( markers_without_null . drop_sel ( axis = \"ones\" ) # drop the axis with only ones . isel ( channel = slice ( 10 , 16 )) # select some markers . plot . line ( x = \"time\" , col = \"channel\" , hue = \"axis\" , col_wrap = 3 ) # plot the data ) Application: electromyographic pipeline Pyomeca implements specialized functionalities commonly used in biomechanics. As an example, let's process the electromyographic data contained in our c3d file. from pyomeca import Analogs muscles = [ \"Delt_ant\" , \"Delt_med\" , \"Delt_post\" , \"Supra\" , \"Infra\" , \"Subscap\" , ] emg = Analogs . from_c3d ( data_path , suffix_delimiter = \".\" , usecols = muscles ) emg . plot ( x = \"time\" , col = \"channel\" , col_wrap = 3 ) emg_processed = ( emg . meca . band_pass ( order = 2 , cutoff = [ 10 , 425 ]) . meca . center () . meca . abs () . meca . low_pass ( order = 4 , cutoff = 5 , freq = emg . rate ) . meca . normalize () ) emg_processed . plot ( x = \"time\" , col = \"channel\" , col_wrap = 3 ) By updating the metadata ( attrs dictionary), we can update the name and units on our plots. emg_processed . name = \"EMG\" emg_processed . attrs [ \"units\" ] = \"%\" emg_processed . time . attrs [ \"units\" ] = \"seconds\" emg_processed . plot ( x = \"time\" , col = \"channel\" , col_wrap = 3 ) fig , axes = plt . subplots ( ncols = 2 , figsize = ( 10 , 4 )) emg_processed . mean ( \"channel\" ) . plot ( ax = axes [ 0 ]) axes [ 0 ] . set_title ( \"Mean EMG activation\" ) emg_processed . plot . hist ( ax = axes [ 1 ], bins = 50 ) axes [ 1 ] . set_title ( \"EMG activation distribution\" ) By converting the data array to a pandas dataframe, we can further extend the possibilities: emg_dataframe = emg_processed . meca . to_wide_dataframe () emg_dataframe . plot . box ( showfliers = False ) emg_dataframe . corr () . style . background_gradient () . set_precision ( 2 ) #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row0_col0 { background-color: #023858; color: #f1f1f1; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row0_col1 { background-color: #e9e5f1; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row0_col2 { background-color: #fff7fb; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row0_col3 { background-color: #b5c4df; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row0_col4 { background-color: #fff7fb; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row0_col5 { background-color: #fff7fb; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row1_col0 { background-color: #308cbe; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row1_col1 { background-color: #023858; color: #f1f1f1; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row1_col2 { background-color: #3790c0; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row1_col3 { background-color: #b5c4df; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row1_col4 { background-color: #9ebad9; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row1_col5 { background-color: #0872b1; color: #f1f1f1; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row2_col0 { background-color: #fff7fb; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row2_col1 { background-color: #efe9f3; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row2_col2 { background-color: #023858; color: #f1f1f1; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row2_col3 { background-color: #fcf4fa; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row2_col4 { background-color: #e2dfee; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row2_col5 { background-color: #3f93c2; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row3_col0 { background-color: #4c99c5; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row3_col1 { background-color: #fff7fb; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row3_col2 { background-color: #a1bbda; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row3_col3 { background-color: #023858; color: #f1f1f1; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row3_col4 { background-color: #faf2f8; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row3_col5 { background-color: #a7bddb; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row4_col0 { background-color: #afc1dd; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row4_col1 { background-color: #f5eff6; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row4_col2 { background-color: #84b0d3; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row4_col3 { background-color: #fff7fb; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row4_col4 { background-color: #023858; color: #f1f1f1; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row4_col5 { background-color: #88b1d4; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row5_col0 { background-color: #abbfdc; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row5_col1 { background-color: #4094c3; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row5_col2 { background-color: #0570b0; color: #f1f1f1; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row5_col3 { background-color: #abbfdc; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row5_col4 { background-color: #83afd3; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row5_col5 { background-color: #023858; color: #f1f1f1; } channel Delt_ant Delt_med Delt_post Infra Subscap Supra channel Delt_ant 1.0 0.78 0.38 0.74 0.6 0.6 Delt_med 0.78 1.0 0.77 0.74 0.76 0.9 Delt_post 0.38 0.77 1.0 0.62 0.67 0.84 Infra 0.74 0.74 0.62 1.0 0.61 0.75 Subscap 0.6 0.76 0.67 0.61 1.0 0.78 Supra 0.6 0.9 0.84 0.75 0.78 1.0 Note For more details, see the data processing section of the documentation. Datasets Datasets are a useful xarray feature to store multiple data arrays with common dimensions import xarray as xr import numpy as np trials = xr . Dataset ( { \"trial 1\" : emg , \"trial 2\" : emg * np . random . rand (), \"trial 3\" : emg * np . random . rand (), } ) trials <xarray.Dataset> Dimensions: (channel: 6, time: 11600) Coordinates: * channel (channel) <U9 'Delt_ant' 'Delt_med' ... 'Infra' 'Subscap' * time (time) float64 0.0 0.0005 0.001 0.0015 ... 5.798 5.798 5.799 5.8 Data variables: trial 1 (channel, time) float64 -2.609e-05 -2.544e-05 ... 3.04e-05 trial 2 (channel, time) float64 -5.21e-06 -5.081e-06 ... 6.071e-06 trial 3 (channel, time) float64 -1.355e-05 -1.321e-05 ... 1.578e-05 We can still access the individual data arrays trials [ \"trial 1\" ] <xarray.DataArray 'trial 1' (channel: 6, time: 11600)> array([[-2.60891229e-05, -2.54411752e-05, -2.45576939e-05, ..., -1.93931046e-05, -1.97550762e-05, -1.91258678e-05], [-4.02107289e-05, -6.80835801e-05, -8.64052563e-05, ..., 4.98310801e-05, 4.22991216e-05, 3.81295613e-05], [-1.36110339e-05, -1.32793148e-05, -1.27393068e-05, ..., -2.54613460e-05, -2.30687110e-05, -1.89858001e-05], [ 2.97530321e-04, 1.55170274e-04, 3.52776406e-05, ..., -2.58133630e-04, -4.46292252e-04, -5.75785409e-04], [ 2.23239495e-05, 2.26500360e-05, 2.28447316e-05, ..., 8.95366975e-06, -3.41701161e-06, 1.05170475e-05], [ 2.87022194e-05, 2.90283060e-05, 2.90723892e-05, ..., 2.92962086e-05, 2.90890512e-05, 3.03986035e-05]]) Coordinates: * channel (channel) <U9 'Delt_ant' 'Delt_med' ... 'Infra' 'Subscap' * time (time) float64 0.0 0.0005 0.001 0.0015 ... 5.798 5.798 5.799 5.8 Attributes: first_frame: 0 last_frame: 11580 rate: 2000.0 units: V While being able to do indexing and computation on the whole dataset trials . sel ( channel = \"Infra\" ) + 100 <xarray.Dataset> Dimensions: (time: 11600) Coordinates: channel <U9 'Infra' * time (time) float64 0.0 0.0005 0.001 0.0015 ... 5.798 5.798 5.799 5.8 Data variables: trial 1 (time) float64 100.0 100.0 100.0 100.0 ... 100.0 100.0 100.0 100.0 trial 2 (time) float64 100.0 100.0 100.0 100.0 ... 100.0 100.0 100.0 100.0 trial 3 (time) float64 100.0 100.0 100.0 100.0 ... 100.0 100.0 100.0 100.0 Note If you are processing large amount of data, you can leverage Dask to support parallel computations. Dask divides large amount of data into manageable chunks and represents parallel computations with task graphs that are executed either on your laptop or on a large cluster of machines. Xarray has built-in support for dask on both DataArray and Dataset . To see examples and use cases, check out the xarray documentation . File IO NetCDF is the recommended file format to save and share xarray objects. emg . to_netcdf ( \"emg.nc\" ) xr . open_dataarray ( \"emg.nc\" ) <xarray.DataArray 'analogs' (channel: 6, time: 11600)> array([[-2.608912e-05, -2.544118e-05, -2.455769e-05, ..., -1.939310e-05, -1.975508e-05, -1.912587e-05], [-4.021073e-05, -6.808358e-05, -8.640526e-05, ..., 4.983108e-05, 4.229912e-05, 3.812956e-05], [-1.361103e-05, -1.327931e-05, -1.273931e-05, ..., -2.546135e-05, -2.306871e-05, -1.898580e-05], [ 2.975303e-04, 1.551703e-04, 3.527764e-05, ..., -2.581336e-04, -4.462923e-04, -5.757854e-04], [ 2.232395e-05, 2.265004e-05, 2.284473e-05, ..., 8.953670e-06, -3.417012e-06, 1.051705e-05], [ 2.870222e-05, 2.902831e-05, 2.907239e-05, ..., 2.929621e-05, 2.908905e-05, 3.039860e-05]]) Coordinates: * time (time) float64 0.0 0.0005 0.001 0.0015 ... 5.798 5.798 5.799 5.8 * channel (channel) object 'Delt_ant' 'Delt_med' ... 'Infra' 'Subscap' Attributes: first_frame: 0 last_frame: 11580 rate: 2000.0 units: V trials . to_netcdf ( \"trials.nc\" ) xr . open_dataset ( \"trials.nc\" ) <xarray.Dataset> Dimensions: (channel: 6, time: 11600) Coordinates: * time (time) float64 0.0 0.0005 0.001 0.0015 ... 5.798 5.798 5.799 5.8 * channel (channel) object 'Delt_ant' 'Delt_med' ... 'Infra' 'Subscap' Data variables: trial 1 (channel, time) float64 ... trial 2 (channel, time) float64 ... trial 3 (channel, time) float64 ... Pyomeca implements function to read various file format commonly used in biomechanics such as c3d , csv , xlsx , sto , trc and mot . Users can also write Matlab and csv files. emg . meca . to_matlab ( \"emg.mat\" ) emg . meca . to_csv ( \"emg.csv\" )","title":"Getting Started"},{"location":"getting-started/#installation","text":"Before you can use pyomeca, you will need to get it installed. Pyomeca itself is a pure Python package, but its dependencies are not. The easiest way to get everything installed is to use conda . To install pyomeca with its recommended dependencies using the conda command line tool: conda install -c conda-forge pyomeca Now that you have installed pyomeca, you should be able to import it: import pyomeca Note Want to test pyomeca from your browser and without installing anything? Try out our binder server:","title":"Installation"},{"location":"getting-started/#quick-overview","text":"Here is a short introduction to xarray and pyomeca, geared mainly for new users. You should be able to follow along and complete this short example in about 10 minutes. We will carry out common tasks in biomechanics, including reading files, manipulating and processing data, making figures and writing files.","title":"Quick overview"},{"location":"getting-started/#object-creation","text":"Let's begin by creating a biomechanical data structure with pyomeca. In this tutorial, we will analyze the skin marker data available in this c3d file . Pyomeca provides the from_c3d function to read c3d files. As we want to analyse markers data, we will use the Markers class: from pyomeca import Markers data_path = \"../tests/data/markers_analogs.c3d\" markers = Markers . from_c3d ( data_path , prefix_delimiter = \":\" ) Make sure to always have a check on the data after reading it. When used in Jupyter notebooks , data can be explored interactively. A standard text representation is available otherwise. markers Show/Hide data repr Show/Hide attributes /* CSS stylesheet for displaying xarray objects in jupyterlab. * */ :root { --xr-font-color0: var(--jp-content-font-color0, rgba(0, 0, 0, 1)); --xr-font-color2: var(--jp-content-font-color2, rgba(0, 0, 0, 0.54)); --xr-font-color3: var(--jp-content-font-color3, rgba(0, 0, 0, 0.38)); --xr-border-color: var(--jp-border-color2, #e0e0e0); --xr-disabled-color: var(--jp-layout-color3, #bdbdbd); --xr-background-color: var(--jp-layout-color0, white); --xr-background-color-row-even: var(--jp-layout-color1, white); --xr-background-color-row-odd: var(--jp-layout-color2, #eeeeee); } .xr-wrap { min-width: 300px; max-width: 700px; } .xr-header { padding-top: 6px; padding-bottom: 6px; margin-bottom: 4px; border-bottom: solid 1px var(--xr-border-color); } .xr-header > div, .xr-header > ul { display: inline; margin-top: 0; margin-bottom: 0; } .xr-obj-type, .xr-array-name { margin-left: 2px; margin-right: 10px; } .xr-obj-type { color: var(--xr-font-color2); } .xr-sections { padding-left: 0 !important; display: grid; grid-template-columns: 150px auto auto 1fr 20px 20px; } .xr-section-item { display: contents; } .xr-section-item input { display: none; } .xr-section-item input + label { color: var(--xr-disabled-color); } .xr-section-item input:enabled + label { cursor: pointer; color: var(--xr-font-color2); } .xr-section-item input:enabled + label:hover { color: var(--xr-font-color0); } .xr-section-summary { grid-column: 1; color: var(--xr-font-color2); font-weight: 500; } .xr-section-summary > span { display: inline-block; padding-left: 0.5em; } .xr-section-summary-in:disabled + label { color: var(--xr-font-color2); } .xr-section-summary-in + label:before { display: inline-block; content: '\u25ba'; font-size: 11px; width: 15px; text-align: center; } .xr-section-summary-in:disabled + label:before { color: var(--xr-disabled-color); } .xr-section-summary-in:checked + label:before { content: '\u25bc'; } .xr-section-summary-in:checked + label > span { display: none; } .xr-section-summary, .xr-section-inline-details { padding-top: 4px; padding-bottom: 4px; } .xr-section-inline-details { grid-column: 2 / -1; } .xr-section-details { display: none; grid-column: 1 / -1; margin-bottom: 5px; } .xr-section-summary-in:checked ~ .xr-section-details { display: contents; } .xr-array-wrap { grid-column: 1 / -1; display: grid; grid-template-columns: 20px auto; } .xr-array-wrap > label { grid-column: 1; vertical-align: top; } .xr-preview { color: var(--xr-font-color3); } .xr-array-preview, .xr-array-data { padding: 0 5px !important; grid-column: 2; } .xr-array-data, .xr-array-in:checked ~ .xr-array-preview { display: none; } .xr-array-in:checked ~ .xr-array-data, .xr-array-preview { display: inline-block; } .xr-dim-list { display: inline-block !important; list-style: none; padding: 0 !important; margin: 0; } .xr-dim-list li { display: inline-block; padding: 0; margin: 0; } .xr-dim-list:before { content: '('; } .xr-dim-list:after { content: ')'; } .xr-dim-list li:not(:last-child):after { content: ','; padding-right: 5px; } .xr-has-index { font-weight: bold; } .xr-var-list, .xr-var-item { display: contents; } .xr-var-item > div, .xr-var-item label, .xr-var-item > .xr-var-name span { background-color: var(--xr-background-color-row-even); margin-bottom: 0; } .xr-var-item > .xr-var-name:hover span { padding-right: 5px; } .xr-var-list > li:nth-child(odd) > div, .xr-var-list > li:nth-child(odd) > label, .xr-var-list > li:nth-child(odd) > .xr-var-name span { background-color: var(--xr-background-color-row-odd); } .xr-var-name { grid-column: 1; } .xr-var-dims { grid-column: 2; } .xr-var-dtype { grid-column: 3; text-align: right; color: var(--xr-font-color2); } .xr-var-preview { grid-column: 4; } .xr-var-name, .xr-var-dims, .xr-var-dtype, .xr-preview, .xr-attrs dt { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; padding-right: 10px; } .xr-var-name:hover, .xr-var-dims:hover, .xr-var-dtype:hover, .xr-attrs dt:hover { overflow: visible; width: auto; z-index: 1; } .xr-var-attrs, .xr-var-data { display: none; background-color: var(--xr-background-color) !important; padding-bottom: 5px !important; } .xr-var-attrs-in:checked ~ .xr-var-attrs, .xr-var-data-in:checked ~ .xr-var-data { display: block; } .xr-var-data > table { float: right; } .xr-var-name span, .xr-var-data, .xr-attrs { padding-left: 25px !important; } .xr-attrs, .xr-var-attrs, .xr-var-data { grid-column: 1 / -1; } dl.xr-attrs { padding: 0; margin: 0; display: grid; grid-template-columns: 125px auto; } .xr-attrs dt, dd { padding: 0; margin: 0; float: left; padding-right: 10px; width: auto; } .xr-attrs dt { font-weight: normal; grid-column: 1; } .xr-attrs dt:hover span { display: inline-block; background: var(--xr-background-color); padding-right: 10px; } .xr-attrs dd { grid-column: 2; white-space: pre-wrap; word-break: break-all; } .xr-icon-database, .xr-icon-file-text2 { display: inline-block; vertical-align: middle; width: 1em; height: 1.5em !important; stroke-width: 0; stroke: currentColor; fill: currentColor; } xarray.DataArray 'markers' axis : 4 channel : 51 time : 580 44.16 44.17 44.16 44.17 44.17 44.19 44.2 ... 1.0 1.0 1.0 1.0 1.0 1.0 array([[[ 44.16278839, 44.16666412, 44.16487122, ..., 99.22426605, 99.24201965, 99.25963593], [ 32.57229614, 32.57104111, 32.56489563, ..., 87.51286316, 87.52822876, 87.54118347], [ -93.72181702, -93.72447968, -93.72324371, ..., -41.1590271 , -41.14812851, -41.12734985], ..., [ 562.26068115, 562.41027832, 562.56695557, ..., 625.63555908, 625.98504639, 626.25811768], [ 568.24200439, 568.37792969, 568.49249268, ..., 624.18139648, 624.51190186, 624.78894043], [ 568.44470215, 568.52038574, 568.59216309, ..., 623.09222412, 623.44036865, 623.75152588]], [[-276.86193848, -276.86169434, -276.86407471, ..., -259.15292358, -259.16690063, -259.17092896], [-243.14048767, -243.14073181, -243.13331604, ..., -225.44718933, -225.45556641, -225.46226501], [ 124.78598022, 124.78731537, 124.78870392, ..., 141.820755 , 141.80741882, 141.80308533], ..., [ 638.35144043, 638.4241333 , 638.50653076, ..., 592.00372314, 592.15686035, 592.27819824], [ 626.79144287, 626.86114502, 626.90710449, ..., 584.15661621, 584.27709961, 584.38830566], [ 651.37927246, 651.45532227, 651.49957275, ..., 610.59655762, 610.72821045, 610.84472656]], [[ 675.69683838, 675.69873047, 675.6986084 , ..., 903.97650146, 903.96801758, 903.980896 ], [ 676.57452393, 676.58099365, 676.57720947, ..., 904.61694336, 904.61645508, 904.63104248], [ 674.27874756, 674.27947998, 674.28033447, ..., 902.77349854, 902.77819824, 902.78143311], ..., [ 81.34425354, 81.32899475, 81.2776413 , ..., 53.45215607, 53.57727814, 53.72877121], [ 110.84020996, 110.81329346, 110.76582336, ..., 83.92819214, 84.07093048, 84.20204163], [ 129.69673157, 129.6789856 , 129.62939453, ..., 99.39131165, 99.52735138, 99.68258667]], [[ 1. , 1. , 1. , ..., 1. , 1. , 1. ], [ 1. , 1. , 1. , ..., 1. , 1. , 1. ], [ 1. , 1. , 1. , ..., 1. , 1. , 1. ], ..., [ 1. , 1. , 1. , ..., 1. , 1. , 1. ], [ 1. , 1. , 1. , ..., 1. , 1. , 1. ], [ 1. , 1. , 1. , ..., 1. , 1. , 1. ]]]) Coordinates: (3) axis (axis) <U4 'x' 'y' 'z' 'ones' array(['x', 'y', 'z', 'ones'], dtype='<U4') channel (channel) <U14 'gauche_ext' ... 'LATH' array(['gauche_ext', 'gauche_int', 'droite_int', 'droite_ext', 'avant_gauche', 'avant_droit', 'arriere_droit', 'arriere_gauche', 'ASISr', 'ASISl', 'PSISr', 'PSISl', 'STERr', 'STERl', 'STER', 'XIPH', 'T1', 'T10', 'CLAV_SC', 'CLAVm', 'CLAV_ant', 'CLAV_post', 'CLAVl', 'CLAV_AC', 'ACRO_tip', 'SCAP_AA', 'SCAPl', 'SCAPm', 'SCAP_CP', 'SCAP_RS', 'SCAP_SA', 'SCAP_IA', 'DELT', 'ARMl', 'ARMm', 'ARMp_up', 'ARMp_do', 'EPICl', 'EPICm', 'LARMm', 'LARMl', 'LARM_elb', 'LARM_ant', 'STYLr', 'STYLr_up', 'STYLu', 'WRIST', 'INDEX', 'LASTC', 'MEDH', 'LATH'], dtype='<U14') time (time) float64 0.0 0.01 0.02 ... 5.77 5.78 5.79 array([0. , 0.01, 0.02, ..., 5.77, 5.78, 5.79]) Attributes: (4) first_frame : 0 last_frame : 579 rate : 100.0 units : mm In this case, we have generated a 3D array with the axis , channel and time dimensions. Note There are several ways to create objects in pyomeca: by supplying data, from files or from other data-structure. A more complete guide on object creation is available in the object creation section of the documentation.","title":"Object creation"},{"location":"getting-started/#indexing","text":"Since we have labels associated with each dimension, we have several kinds of indexing available with varying levels of convenience and intuitiveness. Let's see three ways to get the same data (ninth marker and first time frame).","title":"Indexing"},{"location":"getting-started/#positional-indexing","text":"Indexing directly works just like it does for numpy arrays. markers [:, 9 , 0 ] <xarray.DataArray 'markers' (axis: 4)> array([753.43908691, 75.9487381 , 187.7590332 , 1. ]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' channel <U14 'ASISl' time float64 0.0 Attributes: first_frame: 0 last_frame: 579 rate: 100.0 units: mm","title":"Positional indexing"},{"location":"getting-started/#label-based-indexing","text":"Label-based indexing frees us from having to know how the data are organized. We do not have to rely on dimension order and can use them explicitly to index the data. The isel method is used when the dimension lookup is by name and the index lookup is by integer markers . isel ( channel = 9 , time = 0 ) <xarray.DataArray 'markers' (axis: 4)> array([753.43908691, 75.9487381 , 187.7590332 , 1. ]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' channel <U14 'ASISl' time float64 0.0 Attributes: first_frame: 0 last_frame: 579 rate: 100.0 units: mm The sel method is used when the dimension and index lookups are both by name. markers . sel ( channel = \"ASISl\" , time = 0 ) <xarray.DataArray 'markers' (axis: 4)> array([753.43908691, 75.9487381 , 187.7590332 , 1. ]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' channel <U14 'ASISl' time float64 0.0 Attributes: first_frame: 0 last_frame: 579 rate: 100.0 units: mm Note xarray offers extremely flexible indexing routines. For more details on indexing see the xarray documentation .","title":"Label-based indexing"},{"location":"getting-started/#metadata","text":"Biomechanical datasets are usually more than just raw numbers and have various metadata attributes. Some metadata are already filled by pyomeca and available in the attrs Python dictionary. markers . attrs >> {'first_frame': 0, 'last_frame': 579, 'rate': 100.0, 'units': 'mm'} They can be accessed using the standard dictionary indexing markers . attrs [ \"rate\" ] >> 100.0 Or directly as a propriety markers . rate >> 100.0 You can assign anything you wish. markers . attrs [ \"description\" ] = \"Skin marker positions recorded in Montreal.\" markers . attrs [ \"participant_id\" ] = 12 markers . time . attrs [ \"units\" ] = \"seconds\" markers <xarray.DataArray 'markers' (axis: 4, channel: 51, time: 580)> array([[[ 44.16278839, 44.16666412, 44.16487122, ..., 99.22426605, 99.24201965, 99.25963593], [ 32.57229614, 32.57104111, 32.56489563, ..., 87.51286316, 87.52822876, 87.54118347], [ -93.72181702, -93.72447968, -93.72324371, ..., -41.1590271 , -41.14812851, -41.12734985], ..., [ 562.26068115, 562.41027832, 562.56695557, ..., 625.63555908, 625.98504639, 626.25811768], [ 568.24200439, 568.37792969, 568.49249268, ..., 624.18139648, 624.51190186, 624.78894043], [ 568.44470215, 568.52038574, 568.59216309, ..., 623.09222412, 623.44036865, 623.75152588]], [[-276.86193848, -276.86169434, -276.86407471, ..., -259.15292358, -259.16690063, -259.17092896], [-243.14048767, -243.14073181, -243.13331604, ..., -225.44718933, -225.45556641, -225.46226501], [ 124.78598022, 124.78731537, 124.78870392, ..., 141.820755 , 141.80741882, 141.80308533], ..., [ 638.35144043, 638.4241333 , 638.50653076, ..., 592.00372314, 592.15686035, 592.27819824], [ 626.79144287, 626.86114502, 626.90710449, ..., 584.15661621, 584.27709961, 584.38830566], [ 651.37927246, 651.45532227, 651.49957275, ..., 610.59655762, 610.72821045, 610.84472656]], [[ 675.69683838, 675.69873047, 675.6986084 , ..., 903.97650146, 903.96801758, 903.980896 ], [ 676.57452393, 676.58099365, 676.57720947, ..., 904.61694336, 904.61645508, 904.63104248], [ 674.27874756, 674.27947998, 674.28033447, ..., 902.77349854, 902.77819824, 902.78143311], ..., [ 81.34425354, 81.32899475, 81.2776413 , ..., 53.45215607, 53.57727814, 53.72877121], [ 110.84020996, 110.81329346, 110.76582336, ..., 83.92819214, 84.07093048, 84.20204163], [ 129.69673157, 129.6789856 , 129.62939453, ..., 99.39131165, 99.52735138, 99.68258667]], [[ 1. , 1. , 1. , ..., 1. , 1. , 1. ], [ 1. , 1. , 1. , ..., 1. , 1. , 1. ], [ 1. , 1. , 1. , ..., 1. , 1. , 1. ], ..., [ 1. , 1. , 1. , ..., 1. , 1. , 1. ], [ 1. , 1. , 1. , ..., 1. , 1. , 1. ], [ 1. , 1. , 1. , ..., 1. , 1. , 1. ]]]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' * channel (channel) <U14 'gauche_ext' 'gauche_int' ... 'MEDH' 'LATH' * time (time) float64 0.0 0.01 0.02 0.03 0.04 ... 5.75 5.76 5.77 5.78 5.79 Attributes: first_frame: 0 last_frame: 579 rate: 100.0 units: mm description: Skin marker positions recorded in Montreal. participant_id: 12","title":"Metadata"},{"location":"getting-started/#computation","text":"","title":"Computation"},{"location":"getting-started/#arithmetic","text":"As the underlying data-structure is a numpy array, xarray data arrays work the same way you would expect if you are used to numpy. subset = markers [:, 0 , : 6 ] subset + 10 <xarray.DataArray 'markers' (axis: 4, time: 6)> array([[ 54.16278839, 54.16666412, 54.16487122, 54.16558075, 54.17311096, 54.18517685], [-266.86193848, -266.86169434, -266.86407471, -266.86123657, -266.85812378, -266.85818481], [ 685.69683838, 685.69873047, 685.6986084 , 685.69775391, 685.7041626 , 685.69592285], [ 11. , 11. , 11. , 11. , 11. , 11. ]]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' channel <U14 'gauche_ext' * time (time) float64 0.0 0.01 0.02 0.03 0.04 0.05 subset . T # transpose <xarray.DataArray 'markers' (time: 6, axis: 4)> array([[ 44.16278839, -276.86193848, 675.69683838, 1. ], [ 44.16666412, -276.86169434, 675.69873047, 1. ], [ 44.16487122, -276.86407471, 675.6986084 , 1. ], [ 44.16558075, -276.86123657, 675.69775391, 1. ], [ 44.17311096, -276.85812378, 675.7041626 , 1. ], [ 44.18517685, -276.85818481, 675.69592285, 1. ]]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' channel <U14 'gauche_ext' * time (time) float64 0.0 0.01 0.02 0.03 0.04 0.05 Attributes: first_frame: 0 last_frame: 579 rate: 100.0 units: mm description: Skin marker positions recorded in Montreal. participant_id: 12 subset . mean () <xarray.DataArray 'markers' ()> array(111.00187318) Coordinates: channel <U14 'gauche_ext' subset . mean ( axis = 1 ) <xarray.DataArray 'markers' (axis: 4)> array([ 44.16969872, -276.86087545, 675.69866943, 1. ]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' channel <U14 'gauche_ext' We can, however, take advantage of the labels instead of axis numbers subset . mean ( dim = \"time\" ) <xarray.DataArray 'markers' (axis: 4)> array([ 44.16969872, -276.86087545, 675.69866943, 1. ]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' channel <U14 'gauche_ext' Arithmetic operations broadcast based on dimension name. This means you don\u2019t need to insert dummy dimensions for alignment: only_first_axis = subset . sel ( axis = \"x\" ) only_first_frame = subset . isel ( time = 0 ) only_first_axis <xarray.DataArray 'markers' (time: 6)> array([44.16278839, 44.16666412, 44.16487122, 44.16558075, 44.17311096, 44.18517685]) Coordinates: axis <U4 'x' channel <U14 'gauche_ext' * time (time) float64 0.0 0.01 0.02 0.03 0.04 0.05 Attributes: first_frame: 0 last_frame: 579 rate: 100.0 units: mm description: Skin marker positions recorded in Montreal. participant_id: 12 only_first_frame <xarray.DataArray 'markers' (axis: 4)> array([ 44.16278839, -276.86193848, 675.69683838, 1. ]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' channel <U14 'gauche_ext' time float64 0.0 Attributes: first_frame: 0 last_frame: 579 rate: 100.0 units: mm description: Skin marker positions recorded in Montreal. participant_id: 12 only_first_frame + only_first_axis <xarray.DataArray 'markers' (axis: 4, time: 6)> array([[ 88.32557678, 88.32945251, 88.32765961, 88.32836914, 88.33589935, 88.34796524], [-232.69915009, -232.69527435, -232.69706726, -232.69635773, -232.68882751, -232.67676163], [ 719.85962677, 719.8635025 , 719.86170959, 719.86241913, 719.86994934, 719.88201523], [ 45.16278839, 45.16666412, 45.16487122, 45.16558075, 45.17311096, 45.18517685]]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' channel <U14 'gauche_ext' * time (time) float64 0.0 0.01 0.02 0.03 0.04 0.05 Let's compare with the sum made with numpy arrays: only_first_axis . values + only_first_axis . values >> array([88.32557678, 88.33332825, 88.32974243, 88.3311615 , 88.34622192, 88.3703537 ]) And we do not need to worry about the order of dimensions. subset - subset . T <xarray.DataArray 'markers' (axis: 4, time: 6)> array([[0., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 0., 0.]]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' channel <U14 'gauche_ext' * time (time) float64 0.0 0.01 0.02 0.03 0.04 0.05 Whereas this is not possible with numpy arrays: subset.values - subset.values.T >> ValueError: operands could not be broadcast together with shapes (4,6) (6,4) Note xarray supports powerful shortcuts for computation. For more, see the xarray documentation .","title":"Arithmetic"},{"location":"getting-started/#application-exploring-missing-values","text":"When we visualize some of our markers, we can realize that there are some missing values. markers . sel ( axis = \"x\" , channel = \"SCAP_CP\" ) . plot . line ( x = \"time\" ) Let's investigate those missing values markers_null_values = markers . sel ( axis = \"x\" ) . isnull () print ( f \"There are { markers_null_values . sum () . values } missing values\" ) >> There are 305 missing values What are the 5 markers with the most missing values? markers_null_values . sum ( dim = \"time\" ) . to_series () . nlargest ( 5 ) . plot . barh () The cumulative number of missing values can tell us when marker occlusions occur. markers_null_values . sum ( \"channel\" ) . cumsum ( \"time\" ) . plot () Now that we know more about the missing values, we can use xarray for filling missing values via 1D interpolation. markers_without_null = markers . interpolate_na ( dim = \"time\" , method = \"cubic\" ) Now, let's visualize our interpolated markers. import matplotlib.pyplot as plt markers . sel ( axis = \"x\" , channel = \"SCAP_CP\" ) . plot . line ( x = \"time\" ) ( markers_without_null . where ( markers . isnull ()) . sel ( axis = \"x\" , channel = \"SCAP_CP\" ) . plot . line ( x = \"time\" , label = \"interpolated\" , color = \"r\" ) ) plt . legend () ( markers_without_null . drop_sel ( axis = \"ones\" ) # drop the axis with only ones . isel ( channel = slice ( 10 , 16 )) # select some markers . plot . line ( x = \"time\" , col = \"channel\" , hue = \"axis\" , col_wrap = 3 ) # plot the data )","title":"Application: exploring missing values"},{"location":"getting-started/#application-electromyographic-pipeline","text":"Pyomeca implements specialized functionalities commonly used in biomechanics. As an example, let's process the electromyographic data contained in our c3d file. from pyomeca import Analogs muscles = [ \"Delt_ant\" , \"Delt_med\" , \"Delt_post\" , \"Supra\" , \"Infra\" , \"Subscap\" , ] emg = Analogs . from_c3d ( data_path , suffix_delimiter = \".\" , usecols = muscles ) emg . plot ( x = \"time\" , col = \"channel\" , col_wrap = 3 ) emg_processed = ( emg . meca . band_pass ( order = 2 , cutoff = [ 10 , 425 ]) . meca . center () . meca . abs () . meca . low_pass ( order = 4 , cutoff = 5 , freq = emg . rate ) . meca . normalize () ) emg_processed . plot ( x = \"time\" , col = \"channel\" , col_wrap = 3 ) By updating the metadata ( attrs dictionary), we can update the name and units on our plots. emg_processed . name = \"EMG\" emg_processed . attrs [ \"units\" ] = \"%\" emg_processed . time . attrs [ \"units\" ] = \"seconds\" emg_processed . plot ( x = \"time\" , col = \"channel\" , col_wrap = 3 ) fig , axes = plt . subplots ( ncols = 2 , figsize = ( 10 , 4 )) emg_processed . mean ( \"channel\" ) . plot ( ax = axes [ 0 ]) axes [ 0 ] . set_title ( \"Mean EMG activation\" ) emg_processed . plot . hist ( ax = axes [ 1 ], bins = 50 ) axes [ 1 ] . set_title ( \"EMG activation distribution\" ) By converting the data array to a pandas dataframe, we can further extend the possibilities: emg_dataframe = emg_processed . meca . to_wide_dataframe () emg_dataframe . plot . box ( showfliers = False ) emg_dataframe . corr () . style . background_gradient () . set_precision ( 2 ) #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row0_col0 { background-color: #023858; color: #f1f1f1; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row0_col1 { background-color: #e9e5f1; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row0_col2 { background-color: #fff7fb; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row0_col3 { background-color: #b5c4df; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row0_col4 { background-color: #fff7fb; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row0_col5 { background-color: #fff7fb; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row1_col0 { background-color: #308cbe; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row1_col1 { background-color: #023858; color: #f1f1f1; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row1_col2 { background-color: #3790c0; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row1_col3 { background-color: #b5c4df; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row1_col4 { background-color: #9ebad9; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row1_col5 { background-color: #0872b1; color: #f1f1f1; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row2_col0 { background-color: #fff7fb; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row2_col1 { background-color: #efe9f3; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row2_col2 { background-color: #023858; color: #f1f1f1; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row2_col3 { background-color: #fcf4fa; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row2_col4 { background-color: #e2dfee; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row2_col5 { background-color: #3f93c2; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row3_col0 { background-color: #4c99c5; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row3_col1 { background-color: #fff7fb; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row3_col2 { background-color: #a1bbda; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row3_col3 { background-color: #023858; color: #f1f1f1; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row3_col4 { background-color: #faf2f8; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row3_col5 { background-color: #a7bddb; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row4_col0 { background-color: #afc1dd; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row4_col1 { background-color: #f5eff6; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row4_col2 { background-color: #84b0d3; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row4_col3 { background-color: #fff7fb; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row4_col4 { background-color: #023858; color: #f1f1f1; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row4_col5 { background-color: #88b1d4; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row5_col0 { background-color: #abbfdc; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row5_col1 { background-color: #4094c3; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row5_col2 { background-color: #0570b0; color: #f1f1f1; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row5_col3 { background-color: #abbfdc; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row5_col4 { background-color: #83afd3; color: #000000; } #T_07534df6_7f2d_11ea_ae69_9cb6d0d1e6f9row5_col5 { background-color: #023858; color: #f1f1f1; } channel Delt_ant Delt_med Delt_post Infra Subscap Supra channel Delt_ant 1.0 0.78 0.38 0.74 0.6 0.6 Delt_med 0.78 1.0 0.77 0.74 0.76 0.9 Delt_post 0.38 0.77 1.0 0.62 0.67 0.84 Infra 0.74 0.74 0.62 1.0 0.61 0.75 Subscap 0.6 0.76 0.67 0.61 1.0 0.78 Supra 0.6 0.9 0.84 0.75 0.78 1.0 Note For more details, see the data processing section of the documentation.","title":"Application: electromyographic pipeline"},{"location":"getting-started/#datasets","text":"Datasets are a useful xarray feature to store multiple data arrays with common dimensions import xarray as xr import numpy as np trials = xr . Dataset ( { \"trial 1\" : emg , \"trial 2\" : emg * np . random . rand (), \"trial 3\" : emg * np . random . rand (), } ) trials <xarray.Dataset> Dimensions: (channel: 6, time: 11600) Coordinates: * channel (channel) <U9 'Delt_ant' 'Delt_med' ... 'Infra' 'Subscap' * time (time) float64 0.0 0.0005 0.001 0.0015 ... 5.798 5.798 5.799 5.8 Data variables: trial 1 (channel, time) float64 -2.609e-05 -2.544e-05 ... 3.04e-05 trial 2 (channel, time) float64 -5.21e-06 -5.081e-06 ... 6.071e-06 trial 3 (channel, time) float64 -1.355e-05 -1.321e-05 ... 1.578e-05 We can still access the individual data arrays trials [ \"trial 1\" ] <xarray.DataArray 'trial 1' (channel: 6, time: 11600)> array([[-2.60891229e-05, -2.54411752e-05, -2.45576939e-05, ..., -1.93931046e-05, -1.97550762e-05, -1.91258678e-05], [-4.02107289e-05, -6.80835801e-05, -8.64052563e-05, ..., 4.98310801e-05, 4.22991216e-05, 3.81295613e-05], [-1.36110339e-05, -1.32793148e-05, -1.27393068e-05, ..., -2.54613460e-05, -2.30687110e-05, -1.89858001e-05], [ 2.97530321e-04, 1.55170274e-04, 3.52776406e-05, ..., -2.58133630e-04, -4.46292252e-04, -5.75785409e-04], [ 2.23239495e-05, 2.26500360e-05, 2.28447316e-05, ..., 8.95366975e-06, -3.41701161e-06, 1.05170475e-05], [ 2.87022194e-05, 2.90283060e-05, 2.90723892e-05, ..., 2.92962086e-05, 2.90890512e-05, 3.03986035e-05]]) Coordinates: * channel (channel) <U9 'Delt_ant' 'Delt_med' ... 'Infra' 'Subscap' * time (time) float64 0.0 0.0005 0.001 0.0015 ... 5.798 5.798 5.799 5.8 Attributes: first_frame: 0 last_frame: 11580 rate: 2000.0 units: V While being able to do indexing and computation on the whole dataset trials . sel ( channel = \"Infra\" ) + 100 <xarray.Dataset> Dimensions: (time: 11600) Coordinates: channel <U9 'Infra' * time (time) float64 0.0 0.0005 0.001 0.0015 ... 5.798 5.798 5.799 5.8 Data variables: trial 1 (time) float64 100.0 100.0 100.0 100.0 ... 100.0 100.0 100.0 100.0 trial 2 (time) float64 100.0 100.0 100.0 100.0 ... 100.0 100.0 100.0 100.0 trial 3 (time) float64 100.0 100.0 100.0 100.0 ... 100.0 100.0 100.0 100.0 Note If you are processing large amount of data, you can leverage Dask to support parallel computations. Dask divides large amount of data into manageable chunks and represents parallel computations with task graphs that are executed either on your laptop or on a large cluster of machines. Xarray has built-in support for dask on both DataArray and Dataset . To see examples and use cases, check out the xarray documentation .","title":"Datasets"},{"location":"getting-started/#file-io","text":"NetCDF is the recommended file format to save and share xarray objects. emg . to_netcdf ( \"emg.nc\" ) xr . open_dataarray ( \"emg.nc\" ) <xarray.DataArray 'analogs' (channel: 6, time: 11600)> array([[-2.608912e-05, -2.544118e-05, -2.455769e-05, ..., -1.939310e-05, -1.975508e-05, -1.912587e-05], [-4.021073e-05, -6.808358e-05, -8.640526e-05, ..., 4.983108e-05, 4.229912e-05, 3.812956e-05], [-1.361103e-05, -1.327931e-05, -1.273931e-05, ..., -2.546135e-05, -2.306871e-05, -1.898580e-05], [ 2.975303e-04, 1.551703e-04, 3.527764e-05, ..., -2.581336e-04, -4.462923e-04, -5.757854e-04], [ 2.232395e-05, 2.265004e-05, 2.284473e-05, ..., 8.953670e-06, -3.417012e-06, 1.051705e-05], [ 2.870222e-05, 2.902831e-05, 2.907239e-05, ..., 2.929621e-05, 2.908905e-05, 3.039860e-05]]) Coordinates: * time (time) float64 0.0 0.0005 0.001 0.0015 ... 5.798 5.798 5.799 5.8 * channel (channel) object 'Delt_ant' 'Delt_med' ... 'Infra' 'Subscap' Attributes: first_frame: 0 last_frame: 11580 rate: 2000.0 units: V trials . to_netcdf ( \"trials.nc\" ) xr . open_dataset ( \"trials.nc\" ) <xarray.Dataset> Dimensions: (channel: 6, time: 11600) Coordinates: * time (time) float64 0.0 0.0005 0.001 0.0015 ... 5.798 5.798 5.799 5.8 * channel (channel) object 'Delt_ant' 'Delt_med' ... 'Infra' 'Subscap' Data variables: trial 1 (channel, time) float64 ... trial 2 (channel, time) float64 ... trial 3 (channel, time) float64 ... Pyomeca implements function to read various file format commonly used in biomechanics such as c3d , csv , xlsx , sto , trc and mot . Users can also write Matlab and csv files. emg . meca . to_matlab ( \"emg.mat\" ) emg . meca . to_csv ( \"emg.csv\" )","title":"File IO"},{"location":"object-creation/","text":"The starting point for working with Pyomeca is to create an object with one of the specific methods associated with the different classes available: Pyomeca offers several ways to create these objects: from scratch, from random data, from files or from other data structures. From scratch The first way to create a data array in Pyomeca is to directly specify the data. Example Angles /api/angles/#pyomeca.angles.Angles Markers /api/markers/#pyomeca.markers.Markers Rototrans /api/rototrans/#pyomeca.rototrans.Rototrans Analogs /api/analogs/#pyomeca.analogs.Analogs From random data We occasionally want to quickly create an object to test implementations or prototype new features. In this case, we could simply use random numerical values. Pyomeca offers a method for directly creating objects from random data. Example Angles /api/angles/#pyomeca.angles.Angles.from_random_data Markers /api/markers/#pyomeca.markers.Markers.from_random_data Rototrans /api/rototrans/#pyomeca.rototrans.Rototrans.from_random_data Analogs /api/analogs/#pyomeca.analogs.Analogs.from_random_data From files Most of the time, we want to create objects from files collected during experimentation. Pyomeca supports most of the formats used in biomechanics. Note Pyomeca does not support a format you need? You can inform us by opening an issue or even submit a pull request to make your implementation available to the whole community! c3d Example Markers /api/markers/#pyomeca.markers.Markers.from_c3d Analogs /api/analogs/#pyomeca.analogs.Analogs.from_c3d csv Example Markers /api/markers/#pyomeca.markers.Markers.from_csv Analogs /api/analogs/#pyomeca.analogs.Analogs.from_csv excel Example Markers /api/markers/#pyomeca.markers.Markers.from_excel Analogs /api/analogs/#pyomeca.analogs.Analogs.from_excel mot Example /api/analogs/#pyomeca.analogs.Analogs.from_mot trc Example /api/markers/#pyomeca.markers.Markers.from_trc sto Example /api/analogs/#pyomeca.analogs.Analogs.from_sto From other data structures We often have to switch between different representations of the same data. Pyomeca implements different matrix manipulation routines such as getting Euler angles or a marker to/from a rototranslation matrix. Angles & Rototrans Example Angles from Rototrans /api/angles/#pyomeca.angles.Angles.from_rototrans Rototrans from Angles /api/rototrans/#pyomeca.rototrans.Rototrans.from_euler_angles Markers & Rototrans Example Markers from Rototrans /api/markers/#pyomeca.markers.Markers.from_rototrans Rototrans from Markers /api/rototrans/#pyomeca.rototrans.Rototrans.from_markers Processed Rototrans Example Rototrans from a transposed Rototrans /api/rototrans/#pyomeca.rototrans.Rototrans.from_transposed_rototrans Rototrans from an averaged Rototrans /api/rototrans/#pyomeca.rototrans.Rototrans.from_averaged_rototrans renderApiTemplate()","title":"Object creation"},{"location":"object-creation/#from-scratch","text":"The first way to create a data array in Pyomeca is to directly specify the data. Example Angles /api/angles/#pyomeca.angles.Angles Markers /api/markers/#pyomeca.markers.Markers Rototrans /api/rototrans/#pyomeca.rototrans.Rototrans Analogs /api/analogs/#pyomeca.analogs.Analogs","title":"From scratch"},{"location":"object-creation/#from-random-data","text":"We occasionally want to quickly create an object to test implementations or prototype new features. In this case, we could simply use random numerical values. Pyomeca offers a method for directly creating objects from random data. Example Angles /api/angles/#pyomeca.angles.Angles.from_random_data Markers /api/markers/#pyomeca.markers.Markers.from_random_data Rototrans /api/rototrans/#pyomeca.rototrans.Rototrans.from_random_data Analogs /api/analogs/#pyomeca.analogs.Analogs.from_random_data","title":"From random data"},{"location":"object-creation/#from-files","text":"Most of the time, we want to create objects from files collected during experimentation. Pyomeca supports most of the formats used in biomechanics. Note Pyomeca does not support a format you need? You can inform us by opening an issue or even submit a pull request to make your implementation available to the whole community! c3d Example Markers /api/markers/#pyomeca.markers.Markers.from_c3d Analogs /api/analogs/#pyomeca.analogs.Analogs.from_c3d csv Example Markers /api/markers/#pyomeca.markers.Markers.from_csv Analogs /api/analogs/#pyomeca.analogs.Analogs.from_csv excel Example Markers /api/markers/#pyomeca.markers.Markers.from_excel Analogs /api/analogs/#pyomeca.analogs.Analogs.from_excel mot Example /api/analogs/#pyomeca.analogs.Analogs.from_mot trc Example /api/markers/#pyomeca.markers.Markers.from_trc sto Example /api/analogs/#pyomeca.analogs.Analogs.from_sto","title":"From files"},{"location":"object-creation/#from-other-data-structures","text":"We often have to switch between different representations of the same data. Pyomeca implements different matrix manipulation routines such as getting Euler angles or a marker to/from a rototranslation matrix.","title":"From other data structures"},{"location":"object-creation/#angles-rototrans","text":"Example Angles from Rototrans /api/angles/#pyomeca.angles.Angles.from_rototrans Rototrans from Angles /api/rototrans/#pyomeca.rototrans.Rototrans.from_euler_angles","title":"Angles &amp; Rototrans"},{"location":"object-creation/#markers-rototrans","text":"Example Markers from Rototrans /api/markers/#pyomeca.markers.Markers.from_rototrans Rototrans from Markers /api/rototrans/#pyomeca.rototrans.Rototrans.from_markers","title":"Markers &amp; Rototrans"},{"location":"object-creation/#processed-rototrans","text":"Example Rototrans from a transposed Rototrans /api/rototrans/#pyomeca.rototrans.Rototrans.from_transposed_rototrans Rototrans from an averaged Rototrans /api/rototrans/#pyomeca.rototrans.Rototrans.from_averaged_rototrans renderApiTemplate()","title":"Processed Rototrans"},{"location":"overview/","text":"Working with labelled multidimensional arrays Pyomeca introduces a concise interface to read, analyse, visualize and plot biomechanical data. Such data are typically multi-dimensional , such as joint angles with associated axes, degrees of freedom and time frames. NumPy is the fundamental package for multi-dimensional computing with Python. While NumPy provides an efficient data structure and an intuitive interface, biomechanical datasets typically contain more than just raw numbers and have labels which encode how the array values map to different dimensions such as axes, degrees of freedom, channels or time frames. Pyomeca is built upon and extends the core strengths of xarray , which keeps tracks of labels and provides a powerful and concise interface which makes it easy to: Apply any operations over dimensions by name ( array.sum(dim=\"time\") ) instead of an arbitrary axis ( array.sum(axis=2) ). Select values by labels ( array.sel(axis=\"x\") or emg.sel(channel=\"biceps\") ). Vectorize computation across multiple dimensions. Use the split-apply-combine paradigm, for example: emg.groupby(\"channel\").mean() or any custom function: emg.groupby('channel').map(lambda x: x - x.mean()) ). Keep track of metadata in the array.attrs Python dictionary ( array.attrs[\"rate\"] ). Extent the xarray interface with domain specific functionalities with custom accessors on xarray objects. In pyomeca, the biomechanics specific functions are registered under the meca name space ( array.meca ). Working with labels makes it much easier to work with multi-dimensional arrays as you do not have to keep track of the order of the dimensions or insert dummy dimensions to align arrays. This allows for a more intuitive, more concise, and less error-prone developer experience. Note As the underlying data structure is still a NumPy array, NumPy functions ( np.abs(array) ) and indexing ( array[:, 0, 1] ) work out of the box. By leveraging xarray data structures, Pyomeca inherits their features such as built-in interpolation , computation , GroupBy , data wrangling , parallel computing and plotting . Extending xarray Xarray is designed as a general-purpose library and tries to avoid including domain specific functionalities. But inevitably, the need for more domain specific logic arises. That's why Pyomeca and dozens of other scientific packages extend xarray. Extending data structure in Python is usually achieved with class inheritance. However inheritance is not very robust for large class such as xarray.DataArray . To add domain specific functionality, pyomeca follows xarray developers' recommendations and use a custom \"accessor\". For more information, you can check out the xarray documentation . Core functionalities Pyomeca has four data structures built upon xarray . Each structure is associated with a specific biomechanical data type and has specialized functionalities: Class Dimensions Description Analogs (\"channel\", \"time\") Generic signals such as EMGs, force signals or any other analog signals Angles (\"axis\", \"channel\", \"time\") Joint angles Markers (\"axis\", \"channel\", \"time\") Skin marker positions Rototrans (\"row\", \"col\", \"time\") Rototranslation matrix While there are technically dozens of functions in pyomeca one can generally group them into two distinct categories: Object creation with the from_* methods. For example, if you want to define a marker array from a csv file: markers = Markers.from_csv(...) . Data processing with the meca array accessor. For example, to low-pass filter our previous markers: markers.meca.low_pass(...) . Note Check out the API reference to see the parameters, use cases and examples associated with each function. You can explore all of pyomeca's public API on the following interactive visualization. Hover the mouse over any block to display a short description with some examples and click to jump to the corresponding API reference. drawApi(\"api-exploration\");","title":"Overview"},{"location":"overview/#working-with-labelled-multidimensional-arrays","text":"Pyomeca introduces a concise interface to read, analyse, visualize and plot biomechanical data. Such data are typically multi-dimensional , such as joint angles with associated axes, degrees of freedom and time frames. NumPy is the fundamental package for multi-dimensional computing with Python. While NumPy provides an efficient data structure and an intuitive interface, biomechanical datasets typically contain more than just raw numbers and have labels which encode how the array values map to different dimensions such as axes, degrees of freedom, channels or time frames. Pyomeca is built upon and extends the core strengths of xarray , which keeps tracks of labels and provides a powerful and concise interface which makes it easy to: Apply any operations over dimensions by name ( array.sum(dim=\"time\") ) instead of an arbitrary axis ( array.sum(axis=2) ). Select values by labels ( array.sel(axis=\"x\") or emg.sel(channel=\"biceps\") ). Vectorize computation across multiple dimensions. Use the split-apply-combine paradigm, for example: emg.groupby(\"channel\").mean() or any custom function: emg.groupby('channel').map(lambda x: x - x.mean()) ). Keep track of metadata in the array.attrs Python dictionary ( array.attrs[\"rate\"] ). Extent the xarray interface with domain specific functionalities with custom accessors on xarray objects. In pyomeca, the biomechanics specific functions are registered under the meca name space ( array.meca ). Working with labels makes it much easier to work with multi-dimensional arrays as you do not have to keep track of the order of the dimensions or insert dummy dimensions to align arrays. This allows for a more intuitive, more concise, and less error-prone developer experience. Note As the underlying data structure is still a NumPy array, NumPy functions ( np.abs(array) ) and indexing ( array[:, 0, 1] ) work out of the box. By leveraging xarray data structures, Pyomeca inherits their features such as built-in interpolation , computation , GroupBy , data wrangling , parallel computing and plotting . Extending xarray Xarray is designed as a general-purpose library and tries to avoid including domain specific functionalities. But inevitably, the need for more domain specific logic arises. That's why Pyomeca and dozens of other scientific packages extend xarray. Extending data structure in Python is usually achieved with class inheritance. However inheritance is not very robust for large class such as xarray.DataArray . To add domain specific functionality, pyomeca follows xarray developers' recommendations and use a custom \"accessor\". For more information, you can check out the xarray documentation .","title":"Working with labelled multidimensional arrays"},{"location":"overview/#core-functionalities","text":"Pyomeca has four data structures built upon xarray . Each structure is associated with a specific biomechanical data type and has specialized functionalities: Class Dimensions Description Analogs (\"channel\", \"time\") Generic signals such as EMGs, force signals or any other analog signals Angles (\"axis\", \"channel\", \"time\") Joint angles Markers (\"axis\", \"channel\", \"time\") Skin marker positions Rototrans (\"row\", \"col\", \"time\") Rototranslation matrix While there are technically dozens of functions in pyomeca one can generally group them into two distinct categories: Object creation with the from_* methods. For example, if you want to define a marker array from a csv file: markers = Markers.from_csv(...) . Data processing with the meca array accessor. For example, to low-pass filter our previous markers: markers.meca.low_pass(...) . Note Check out the API reference to see the parameters, use cases and examples associated with each function. You can explore all of pyomeca's public API on the following interactive visualization. Hover the mouse over any block to display a short description with some examples and click to jump to the corresponding API reference. drawApi(\"api-exploration\");","title":"Core functionalities"},{"location":"api/analogs/","text":"analogs.py Analogs __new__ ( cls , data = None , channels = None , time = None , ** kwargs ) special staticmethod Analogs DataArray with channel and time dimensions used for generic signals such as EMGs, force signals or any other analog signals. Parameters: Name Type Description Default data Optional[Union[<built-in function array>, numpy.ndarray, xarray.core.dataarray.DataArray]] Array to be passed to xarray.DataArray None channels Optional[list] Channel names None time Optional[Union[<built-in function array>, list, pandas.core.series.Series]] Time vector in seconds associated with the data parameter None kwargs Keyword argument(s) to be passed to xarray.DataArray {} Returns: Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates Example To instantiate an Analogs with 4 channels and 100 frames filled with some random data: import numpy as np from pyomeca import Analogs n_channels = 4 n_frames = 100 data = np . random . random ( size = ( n_channels , n_frames )) analogs = Analogs ( data ) You can add the channel names: names = [ \"A\" , \"B\" , \"C\" , \"D\" ] analogs = Analogs ( data , channels = names ) And an associate time vector: rate = 100 # Hz time = np . arange ( start = 0 , stop = n_frames / rate , step = 1 / rate ) analogs = Analogs ( data , channels = names , time = time ) Note Calling Analogs() generate an empty array. Source code in pyomeca/analogs.py def __new__ ( cls , data : Optional [ Union [ np . array , np . ndarray , xr . DataArray ]] = None , channels : Optional [ list ] = None , time : Optional [ Union [ np . array , list , pd . Series ]] = None , ** kwargs , ) -> xr . DataArray : \"\"\" Analogs DataArray with `channel` and `time` dimensions used for generic signals such as EMGs, force signals or any other analog signals. ![analogs](/images/objects/analogs.svg) Arguments: data: Array to be passed to xarray.DataArray channels: Channel names time: Time vector in seconds associated with the `data` parameter kwargs: Keyword argument(s) to be passed to xarray.DataArray Returns: Analogs `xarray.DataArray` with the specified data and coordinates !!! example To instantiate an `Analogs` with 4 channels and 100 frames filled with some random data: ```python import numpy as np from pyomeca import Analogs n_channels = 4 n_frames = 100 data = np.random.random(size=(n_channels, n_frames)) analogs = Analogs(data) ``` You can add the channel names: ```python names = [\"A\", \"B\", \"C\", \"D\"] analogs = Analogs(data, channels=names) ``` And an associate time vector: ```python rate = 100 # Hz time = np.arange(start=0, stop=n_frames / rate, step=1 / rate) analogs = Analogs(data, channels=names, time=time) ``` !!! note Calling `Analogs()` generate an empty array. \"\"\" coords = {} if data is None : data = np . ndarray (( 0 , 0 )) if channels is not None : coords [ \"channel\" ] = channels if time is not None : coords [ \"time\" ] = time return xr . DataArray ( data = data , dims = ( \"channel\" , \"time\" ), coords = coords , name = \"analogs\" , ** kwargs , ) from_c3d ( filename , usecols = None , prefix_delimiter = None , suffix_delimiter = None , attrs = None ) classmethod Analogs DataArray from a c3d file. Parameters: Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None attrs Optional[dict] attrs to be passed to xr.DataArray None Returns: Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates Example To read this c3d file , type: from pyomeca import Analogs data_path = \"./tests/data/markers_analogs.c3d\" analogs = Analogs . from_c3d ( data_path ) If you know the channel names, you can retrieve only the ones you are interested in: channels = [ \"Voltage.1\" , \"Voltage.2\" , \"Voltage.3\" ] analogs = Analogs . from_c3d ( data_path , usecols = channels ) Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify prefix_delimiter and suffix_delimiter for the suffix. For example, if the name is \"Voltage.1\" and you specify suffix_delimiter=\".\" , you will select \"Voltage\". Similarly, if you specify `prefix_delimiter=\".\": channels = [ \"1\" , \"2\" , \"3\" ] analogs = Analogs . from_c3d ( data_path , usecols = channels , prefix_delimiter = \".\" ) Source code in pyomeca/analogs.py @classmethod def from_c3d ( cls , filename : Union [ str , Path ], usecols : Optional [ List [ Union [ str , int ]]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Analogs DataArray from a c3d file. Arguments: filename: Any valid string path usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) attrs: attrs to be passed to xr.DataArray Returns: Analogs `xarray.DataArray` with the specified data and coordinates !!! example To read [this c3d file](https://github.com/pyomeca/pyomeca/blob/master/tests/data/markers_analogs.c3d), type: ```python from pyomeca import Analogs data_path = \"./tests/data/markers_analogs.c3d\" analogs = Analogs.from_c3d(data_path) ``` If you know the channel names, you can retrieve only the ones you are interested in: ```python channels = [\"Voltage.1\", \"Voltage.2\", \"Voltage.3\"] analogs = Analogs.from_c3d(data_path, usecols=channels) ``` Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify `prefix_delimiter` and `suffix_delimiter` for the suffix. For example, if the name is `\"Voltage.1\"` and you specify `suffix_delimiter=\".\"`, you will select \"Voltage\". Similarly, if you specify `prefix_delimiter=\".\": ```python channels = [\"1\", \"2\", \"3\"] analogs = Analogs.from_c3d(data_path, usecols=channels, prefix_delimiter=\".\") ``` \"\"\" return read . read_c3d ( cls , filename , usecols , prefix_delimiter , suffix_delimiter , attrs ) from_csv ( filename , usecols = None , header = None , first_row = 0 , first_column = None , time_column = None , trailing_columns = None , prefix_delimiter = None , suffix_delimiter = None , skip_rows = None , pandas_kwargs = None , attrs = None ) classmethod Analogs DataArray from a csv file. Parameters: Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz'] None header Optional[int] Row of the header (0-indexed) None first_row int First row of the data (0-indexed) 0 first_column Optional[Union[str, int]] First column of the data (0-indexed) None time_column Optional[Union[str, int]] Location of the time column. If None, indices are associated None trailing_columns Optional[Union[str, int]] If for some reason the csv reads extra columns, how many should be ignored None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None skip_rows Optional[List[int]] Line numbers to skip (0-indexed) None pandas_kwargs Optional[dict] Keyword arguments to be passed to pandas.read_csv None attrs Optional[dict] attrs to be passed to xr.DataArray . If attrs['rate'] is provided, compute the time accordingly None Returns: Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates Example To read this csv file , type: from pyomeca import Analogs data_path = \"./tests/data/analogs.csv\" analogs = Analogs . from_csv ( data_path , header = 3 , first_row = 5 , first_column = 2 ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"IM EMG1\" , \"IM EMG2\" , \"IM EMG3\" ] analogs = Analogs . from_csv ( data_path , header = 3 , first_row = 5 , first_column = 2 , usecols = channels ) Or by position: channels = [ 5 , 6 , 7 ] analogs = Analogs . from_csv ( data_path , header = 3 , first_row = 5 , first_column = 2 , usecols = channels ) Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify prefix_delimiter and suffix_delimiter for the suffix. For example, if the name is \"IM EMG1\" and you specify suffix_delimiter=\" \" , you will select \"IM\". Similarly, if you specify `prefix_delimiter=\" \": channels = [ \"EMG1\" , \"EMG2\" , \"EMG3\" ] analogs = Analogs . from_csv ( data_path , header = 3 , first_row = 5 , first_column = 2 , usecols = channels , suffix_delimiter = \" \" , ) It is also possible to specify a column containing the time vector: analogs = Analogs . from_csv ( data_path , header = 3 , first_row = 5 , first_column = 1 , time_column = 0 ) Source code in pyomeca/analogs.py @classmethod def from_csv ( cls , filename : Union [ str , Path ], usecols : Optional [ List [ Union [ str , int ]]] = None , header : Optional [ int ] = None , first_row : int = 0 , first_column : Optional [ Union [ str , int ]] = None , time_column : Optional [ Union [ str , int ]] = None , trailing_columns : Optional [ Union [ str , int ]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , skip_rows : Optional [ List [ int ]] = None , pandas_kwargs : Optional [ dict ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Analogs DataArray from a csv file. Arguments: filename: Any valid string path usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz'] header: Row of the header (0-indexed) first_row: First row of the data (0-indexed) first_column: First column of the data (0-indexed) time_column: Location of the time column. If None, indices are associated trailing_columns: If for some reason the csv reads extra columns, how many should be ignored prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) skip_rows: Line numbers to skip (0-indexed) pandas_kwargs: Keyword arguments to be passed to `pandas.read_csv` attrs: attrs to be passed to `xr.DataArray`. If attrs['rate'] is provided, compute the time accordingly Returns: Analogs `xarray.DataArray` with the specified data and coordinates !!! example To read [this csv file](https://github.com/pyomeca/pyomeca/blob/master/tests/data/analogs.csv), type: ```python from pyomeca import Analogs data_path = \"./tests/data/analogs.csv\" analogs = Analogs.from_csv(data_path, header=3, first_row=5, first_column=2) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"IM EMG1\", \"IM EMG2\", \"IM EMG3\"] analogs = Analogs.from_csv( data_path, header=3, first_row=5, first_column=2, usecols=channels ) ``` Or by position: ```python channels = [5, 6, 7] analogs = Analogs.from_csv( data_path, header=3, first_row=5, first_column=2, usecols=channels ) ``` Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify `prefix_delimiter` and `suffix_delimiter` for the suffix. For example, if the name is `\"IM EMG1\"` and you specify `suffix_delimiter=\" \"`, you will select \"IM\". Similarly, if you specify `prefix_delimiter=\" \": ```python channels = [\"EMG1\", \"EMG2\", \"EMG3\"] analogs = Analogs.from_csv( data_path, header=3, first_row=5, first_column=2, usecols=channels, suffix_delimiter=\" \", ) ``` It is also possible to specify a column containing the time vector: ```python analogs = Analogs.from_csv( data_path, header=3, first_row=5, first_column=1, time_column=0 ) ``` \"\"\" return read . read_csv_or_excel ( cls , \"csv\" , filename , usecols , header , first_row , first_column , time_column , trailing_columns , prefix_delimiter , suffix_delimiter , skip_rows , pandas_kwargs , attrs , ) from_excel ( filename , sheet_name = 0 , usecols = None , header = None , first_row = 0 , first_column = None , time_column = None , trailing_columns = None , prefix_delimiter = None , suffix_delimiter = None , skip_rows = None , pandas_kwargs = None , attrs = None ) classmethod Analogs DataArray from a excel file. Parameters: Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required sheet_name Union[str, int] Strings are used for sheet names. Integers are used in zero-indexed sheet positions 0 usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz'] None header Optional[int] Row of the header (0-indexed) None first_row int First row of the data (0-indexed) 0 first_column Optional[Union[str, int]] First column of the data (0-indexed) None time_column Optional[Union[str, int]] Location of the time column. If None, indices are associated None trailing_columns Optional[Union[str, int]] If for some reason the csv reads extra columns, how many should be ignored None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None skip_rows Optional[List[int]] Line numbers to skip (0-indexed) None pandas_kwargs Optional[dict] Keyword arguments to be passed to pandas.read_excel None attrs Optional[dict] attrs to be passed to xr.DataArray . If attrs['rate'] is provided, compute the time accordingly None Returns: Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates Example To read this excel file , type: from pyomeca import Analogs data_path = \"./tests/data/analogs.xlsx\" analogs = Analogs . from_excel ( data_path , header = 3 , first_row = 5 , first_column = 2 ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"A\" ] analogs = Analogs . from_excel ( data_path , header = 3 , first_row = 5 , first_column = 2 , usecols = channels ) Or by position: channels = [ 1 ] analogs = Analogs . from_excel ( data_path , header = 3 , first_row = 5 , first_column = 2 , usecols = channels ) It is also possible to specify a column containing the time vector: analogs = Analogs . from_excel ( data_path , header = 3 , first_row = 5 , first_column = 1 , time_column = 0 ) Source code in pyomeca/analogs.py @classmethod def from_excel ( cls , filename : Union [ str , Path ], sheet_name : Union [ str , int ] = 0 , usecols : Optional [ List [ Union [ str , int ]]] = None , header : Optional [ int ] = None , first_row : int = 0 , first_column : Optional [ Union [ str , int ]] = None , time_column : Optional [ Union [ str , int ]] = None , trailing_columns : Optional [ Union [ str , int ]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , skip_rows : Optional [ List [ int ]] = None , pandas_kwargs : Optional [ dict ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Analogs DataArray from a excel file. Arguments: filename: Any valid string path sheet_name: Strings are used for sheet names. Integers are used in zero-indexed sheet positions usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz'] header: Row of the header (0-indexed) first_row: First row of the data (0-indexed) first_column: First column of the data (0-indexed) time_column: Location of the time column. If None, indices are associated trailing_columns: If for some reason the csv reads extra columns, how many should be ignored prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) skip_rows: Line numbers to skip (0-indexed) pandas_kwargs: Keyword arguments to be passed to `pandas.read_excel` attrs: attrs to be passed to `xr.DataArray`. If attrs['rate'] is provided, compute the time accordingly Returns: Analogs `xarray.DataArray` with the specified data and coordinates !!! example To read [this excel file](https://github.com/pyomeca/pyomeca/blob/master/tests/data/analogs.xlsx), type: ```python from pyomeca import Analogs data_path = \"./tests/data/analogs.xlsx\" analogs = Analogs.from_excel(data_path, header=3, first_row=5, first_column=2) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"A\"] analogs = Analogs.from_excel( data_path, header=3, first_row=5, first_column=2, usecols=channels ) ``` Or by position: ```python channels = [1] analogs = Analogs.from_excel( data_path, header=3, first_row=5, first_column=2, usecols=channels ) ``` It is also possible to specify a column containing the time vector: ```python analogs = Analogs.from_excel( data_path, header=3, first_row=5, first_column=1, time_column=0 ) ``` \"\"\" return read . read_csv_or_excel ( cls , \"excel\" , filename , usecols , header , first_row , first_column , time_column , trailing_columns , prefix_delimiter , suffix_delimiter , skip_rows , pandas_kwargs , attrs , sheet_name , ) from_mot ( filename , end_header = None , ** kwargs ) classmethod Analogs DataArray from a mot file. Parameters: Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required end_header Optional[bool] Index where endheader appears (0 indexed). If not provided, the index is automatically determined. None kwargs Keyword arguments to be passed to from_csv {} Returns: Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates Example To read this mot file , type: from pyomeca import Analogs data_path = \"./tests/data/inverse_kin.mot\" analogs = Analogs . from_mot ( data_path ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"elbow_flexion\" , \"pro_sup\" ] analogs = Analogs . from_mot ( data_path , usecols = channels ) Or by position: channels = [ 3 , 4 ] analogs = Analogs . from_mot ( data_path , usecols = channels ) Source code in pyomeca/analogs.py @classmethod def from_mot ( cls , filename : Union [ str , Path ], end_header : Optional [ bool ] = None , ** kwargs ) -> xr . DataArray : \"\"\" Analogs DataArray from a mot file. Arguments: filename: Any valid string path end_header: Index where `endheader` appears (0 indexed). If not provided, the index is automatically determined. kwargs: Keyword arguments to be passed to `from_csv` Returns: Analogs `xarray.DataArray` with the specified data and coordinates !!! example To read [this mot file](https://github.com/pyomeca/pyomeca/blob/master/tests/data/inverse_kin.mot), type: ```python from pyomeca import Analogs data_path = \"./tests/data/inverse_kin.mot\" analogs = Analogs.from_mot(data_path) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"elbow_flexion\", \"pro_sup\"] analogs = Analogs.from_mot(data_path, usecols=channels) ``` Or by position: ```python channels = [3, 4] analogs = Analogs.from_mot(data_path, usecols=channels) ``` \"\"\" return read . read_sto_or_mot ( cls , filename , end_header , ** kwargs ) from_random_data ( distribution = 'normal' , size = ( 10 , 100 ), ** kwargs ) classmethod Create random data from a specified distribution (normal by default) using random walk. Parameters: Name Type Description Default distribution str Distribution available in numpy.random 'normal' size tuple Shape of the desired array (10, 100) kwargs Keyword argument(s) to be passed to numpy.random. distribution {} Returns: Type Description DataArray Random Analogs xarray.DataArray sampled from a given distribution Example To instantiate an Analogs with some random data sampled from a normal distribution: from pyomeca import Analogs n_channels = 10 n_frames = 100 size = n_channels , n_frames analogs = Analogs . from_random_data ( size = size ) You can choose any distribution available in numpy.random : analogs = Analogs . from_random_data ( distribution = \"uniform\" , size = size , low = 1 , high = 10 ) Source code in pyomeca/analogs.py @classmethod def from_random_data ( cls , distribution : str = \"normal\" , size : tuple = ( 10 , 100 ), ** kwargs ) -> xr . DataArray : \"\"\" Create random data from a specified distribution (normal by default) using random walk. Arguments: distribution: Distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions) size: Shape of the desired array kwargs: Keyword argument(s) to be passed to numpy.random.`distribution` Returns: Random Analogs `xarray.DataArray` sampled from a given distribution !!! example To instantiate an `Analogs` with some random data sampled from a normal distribution: ```python from pyomeca import Analogs n_channels = 10 n_frames = 100 size = n_channels, n_frames analogs = Analogs.from_random_data(size=size) ``` You can choose any distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions): ```python analogs = Analogs.from_random_data(distribution=\"uniform\", size=size, low=1, high=10) ``` \"\"\" return Analogs ( getattr ( np . random , distribution )( size = size , ** kwargs ) . cumsum ( - 1 )) from_sto ( filename , end_header = None , ** kwargs ) classmethod Analogs DataArray from a sto file. Parameters: Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required end_header Optional[bool] Index where endheader appears (0 indexed). If not provided, the index is automatically determined None kwargs Keyword arguments to be passed to from_csv {} Returns: Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates Example To read this sto file , type: from pyomeca import Analogs data_path = \"./tests/data/inverse_dyn.sto\" analogs = Analogs . from_sto ( data_path ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"shoulder_plane_moment\" , \"shoulder_ele_moment\" ] analogs = Analogs . from_sto ( data_path , usecols = channels ) Or by position: channels = [ 3 , 4 ] analogs = Analogs . from_sto ( data_path , usecols = channels ) Source code in pyomeca/analogs.py @classmethod def from_sto ( cls , filename : Union [ str , Path ], end_header : Optional [ bool ] = None , ** kwargs ) -> xr . DataArray : \"\"\" Analogs DataArray from a sto file. Arguments: filename: Any valid string path end_header: Index where `endheader` appears (0 indexed). If not provided, the index is automatically determined kwargs: Keyword arguments to be passed to `from_csv` Returns: Analogs `xarray.DataArray` with the specified data and coordinates !!! example To read [this sto file](https://github.com/pyomeca/pyomeca/blob/master/tests/data/inverse_dyn.sto), type: ```python from pyomeca import Analogs data_path = \"./tests/data/inverse_dyn.sto\" analogs = Analogs.from_sto(data_path) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"shoulder_plane_moment\", \"shoulder_ele_moment\"] analogs = Analogs.from_sto(data_path, usecols=channels) ``` Or by position: ```python channels = [3, 4] analogs = Analogs.from_sto(data_path, usecols=channels) ``` \"\"\" return read . read_sto_or_mot ( cls , filename , end_header , ** kwargs )","title":"Analogs"},{"location":"api/analogs/#analogspy","text":"","title":"analogs.py"},{"location":"api/analogs/#pyomeca.analogs","text":"","title":"pyomeca.analogs"},{"location":"api/analogs/#pyomeca.analogs.Analogs","text":"","title":"Analogs"},{"location":"api/analogs/#pyomeca.analogs.Analogs.__new__","text":"Analogs DataArray with channel and time dimensions used for generic signals such as EMGs, force signals or any other analog signals. Parameters: Name Type Description Default data Optional[Union[<built-in function array>, numpy.ndarray, xarray.core.dataarray.DataArray]] Array to be passed to xarray.DataArray None channels Optional[list] Channel names None time Optional[Union[<built-in function array>, list, pandas.core.series.Series]] Time vector in seconds associated with the data parameter None kwargs Keyword argument(s) to be passed to xarray.DataArray {} Returns: Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates Example To instantiate an Analogs with 4 channels and 100 frames filled with some random data: import numpy as np from pyomeca import Analogs n_channels = 4 n_frames = 100 data = np . random . random ( size = ( n_channels , n_frames )) analogs = Analogs ( data ) You can add the channel names: names = [ \"A\" , \"B\" , \"C\" , \"D\" ] analogs = Analogs ( data , channels = names ) And an associate time vector: rate = 100 # Hz time = np . arange ( start = 0 , stop = n_frames / rate , step = 1 / rate ) analogs = Analogs ( data , channels = names , time = time ) Note Calling Analogs() generate an empty array. Source code in pyomeca/analogs.py def __new__ ( cls , data : Optional [ Union [ np . array , np . ndarray , xr . DataArray ]] = None , channels : Optional [ list ] = None , time : Optional [ Union [ np . array , list , pd . Series ]] = None , ** kwargs , ) -> xr . DataArray : \"\"\" Analogs DataArray with `channel` and `time` dimensions used for generic signals such as EMGs, force signals or any other analog signals. ![analogs](/images/objects/analogs.svg) Arguments: data: Array to be passed to xarray.DataArray channels: Channel names time: Time vector in seconds associated with the `data` parameter kwargs: Keyword argument(s) to be passed to xarray.DataArray Returns: Analogs `xarray.DataArray` with the specified data and coordinates !!! example To instantiate an `Analogs` with 4 channels and 100 frames filled with some random data: ```python import numpy as np from pyomeca import Analogs n_channels = 4 n_frames = 100 data = np.random.random(size=(n_channels, n_frames)) analogs = Analogs(data) ``` You can add the channel names: ```python names = [\"A\", \"B\", \"C\", \"D\"] analogs = Analogs(data, channels=names) ``` And an associate time vector: ```python rate = 100 # Hz time = np.arange(start=0, stop=n_frames / rate, step=1 / rate) analogs = Analogs(data, channels=names, time=time) ``` !!! note Calling `Analogs()` generate an empty array. \"\"\" coords = {} if data is None : data = np . ndarray (( 0 , 0 )) if channels is not None : coords [ \"channel\" ] = channels if time is not None : coords [ \"time\" ] = time return xr . DataArray ( data = data , dims = ( \"channel\" , \"time\" ), coords = coords , name = \"analogs\" , ** kwargs , )","title":"__new__()"},{"location":"api/analogs/#pyomeca.analogs.Analogs.from_c3d","text":"Analogs DataArray from a c3d file. Parameters: Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None attrs Optional[dict] attrs to be passed to xr.DataArray None Returns: Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates Example To read this c3d file , type: from pyomeca import Analogs data_path = \"./tests/data/markers_analogs.c3d\" analogs = Analogs . from_c3d ( data_path ) If you know the channel names, you can retrieve only the ones you are interested in: channels = [ \"Voltage.1\" , \"Voltage.2\" , \"Voltage.3\" ] analogs = Analogs . from_c3d ( data_path , usecols = channels ) Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify prefix_delimiter and suffix_delimiter for the suffix. For example, if the name is \"Voltage.1\" and you specify suffix_delimiter=\".\" , you will select \"Voltage\". Similarly, if you specify `prefix_delimiter=\".\": channels = [ \"1\" , \"2\" , \"3\" ] analogs = Analogs . from_c3d ( data_path , usecols = channels , prefix_delimiter = \".\" ) Source code in pyomeca/analogs.py @classmethod def from_c3d ( cls , filename : Union [ str , Path ], usecols : Optional [ List [ Union [ str , int ]]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Analogs DataArray from a c3d file. Arguments: filename: Any valid string path usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) attrs: attrs to be passed to xr.DataArray Returns: Analogs `xarray.DataArray` with the specified data and coordinates !!! example To read [this c3d file](https://github.com/pyomeca/pyomeca/blob/master/tests/data/markers_analogs.c3d), type: ```python from pyomeca import Analogs data_path = \"./tests/data/markers_analogs.c3d\" analogs = Analogs.from_c3d(data_path) ``` If you know the channel names, you can retrieve only the ones you are interested in: ```python channels = [\"Voltage.1\", \"Voltage.2\", \"Voltage.3\"] analogs = Analogs.from_c3d(data_path, usecols=channels) ``` Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify `prefix_delimiter` and `suffix_delimiter` for the suffix. For example, if the name is `\"Voltage.1\"` and you specify `suffix_delimiter=\".\"`, you will select \"Voltage\". Similarly, if you specify `prefix_delimiter=\".\": ```python channels = [\"1\", \"2\", \"3\"] analogs = Analogs.from_c3d(data_path, usecols=channels, prefix_delimiter=\".\") ``` \"\"\" return read . read_c3d ( cls , filename , usecols , prefix_delimiter , suffix_delimiter , attrs )","title":"from_c3d()"},{"location":"api/analogs/#pyomeca.analogs.Analogs.from_csv","text":"Analogs DataArray from a csv file. Parameters: Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz'] None header Optional[int] Row of the header (0-indexed) None first_row int First row of the data (0-indexed) 0 first_column Optional[Union[str, int]] First column of the data (0-indexed) None time_column Optional[Union[str, int]] Location of the time column. If None, indices are associated None trailing_columns Optional[Union[str, int]] If for some reason the csv reads extra columns, how many should be ignored None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None skip_rows Optional[List[int]] Line numbers to skip (0-indexed) None pandas_kwargs Optional[dict] Keyword arguments to be passed to pandas.read_csv None attrs Optional[dict] attrs to be passed to xr.DataArray . If attrs['rate'] is provided, compute the time accordingly None Returns: Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates Example To read this csv file , type: from pyomeca import Analogs data_path = \"./tests/data/analogs.csv\" analogs = Analogs . from_csv ( data_path , header = 3 , first_row = 5 , first_column = 2 ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"IM EMG1\" , \"IM EMG2\" , \"IM EMG3\" ] analogs = Analogs . from_csv ( data_path , header = 3 , first_row = 5 , first_column = 2 , usecols = channels ) Or by position: channels = [ 5 , 6 , 7 ] analogs = Analogs . from_csv ( data_path , header = 3 , first_row = 5 , first_column = 2 , usecols = channels ) Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify prefix_delimiter and suffix_delimiter for the suffix. For example, if the name is \"IM EMG1\" and you specify suffix_delimiter=\" \" , you will select \"IM\". Similarly, if you specify `prefix_delimiter=\" \": channels = [ \"EMG1\" , \"EMG2\" , \"EMG3\" ] analogs = Analogs . from_csv ( data_path , header = 3 , first_row = 5 , first_column = 2 , usecols = channels , suffix_delimiter = \" \" , ) It is also possible to specify a column containing the time vector: analogs = Analogs . from_csv ( data_path , header = 3 , first_row = 5 , first_column = 1 , time_column = 0 ) Source code in pyomeca/analogs.py @classmethod def from_csv ( cls , filename : Union [ str , Path ], usecols : Optional [ List [ Union [ str , int ]]] = None , header : Optional [ int ] = None , first_row : int = 0 , first_column : Optional [ Union [ str , int ]] = None , time_column : Optional [ Union [ str , int ]] = None , trailing_columns : Optional [ Union [ str , int ]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , skip_rows : Optional [ List [ int ]] = None , pandas_kwargs : Optional [ dict ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Analogs DataArray from a csv file. Arguments: filename: Any valid string path usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz'] header: Row of the header (0-indexed) first_row: First row of the data (0-indexed) first_column: First column of the data (0-indexed) time_column: Location of the time column. If None, indices are associated trailing_columns: If for some reason the csv reads extra columns, how many should be ignored prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) skip_rows: Line numbers to skip (0-indexed) pandas_kwargs: Keyword arguments to be passed to `pandas.read_csv` attrs: attrs to be passed to `xr.DataArray`. If attrs['rate'] is provided, compute the time accordingly Returns: Analogs `xarray.DataArray` with the specified data and coordinates !!! example To read [this csv file](https://github.com/pyomeca/pyomeca/blob/master/tests/data/analogs.csv), type: ```python from pyomeca import Analogs data_path = \"./tests/data/analogs.csv\" analogs = Analogs.from_csv(data_path, header=3, first_row=5, first_column=2) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"IM EMG1\", \"IM EMG2\", \"IM EMG3\"] analogs = Analogs.from_csv( data_path, header=3, first_row=5, first_column=2, usecols=channels ) ``` Or by position: ```python channels = [5, 6, 7] analogs = Analogs.from_csv( data_path, header=3, first_row=5, first_column=2, usecols=channels ) ``` Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify `prefix_delimiter` and `suffix_delimiter` for the suffix. For example, if the name is `\"IM EMG1\"` and you specify `suffix_delimiter=\" \"`, you will select \"IM\". Similarly, if you specify `prefix_delimiter=\" \": ```python channels = [\"EMG1\", \"EMG2\", \"EMG3\"] analogs = Analogs.from_csv( data_path, header=3, first_row=5, first_column=2, usecols=channels, suffix_delimiter=\" \", ) ``` It is also possible to specify a column containing the time vector: ```python analogs = Analogs.from_csv( data_path, header=3, first_row=5, first_column=1, time_column=0 ) ``` \"\"\" return read . read_csv_or_excel ( cls , \"csv\" , filename , usecols , header , first_row , first_column , time_column , trailing_columns , prefix_delimiter , suffix_delimiter , skip_rows , pandas_kwargs , attrs , )","title":"from_csv()"},{"location":"api/analogs/#pyomeca.analogs.Analogs.from_excel","text":"Analogs DataArray from a excel file. Parameters: Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required sheet_name Union[str, int] Strings are used for sheet names. Integers are used in zero-indexed sheet positions 0 usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz'] None header Optional[int] Row of the header (0-indexed) None first_row int First row of the data (0-indexed) 0 first_column Optional[Union[str, int]] First column of the data (0-indexed) None time_column Optional[Union[str, int]] Location of the time column. If None, indices are associated None trailing_columns Optional[Union[str, int]] If for some reason the csv reads extra columns, how many should be ignored None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None skip_rows Optional[List[int]] Line numbers to skip (0-indexed) None pandas_kwargs Optional[dict] Keyword arguments to be passed to pandas.read_excel None attrs Optional[dict] attrs to be passed to xr.DataArray . If attrs['rate'] is provided, compute the time accordingly None Returns: Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates Example To read this excel file , type: from pyomeca import Analogs data_path = \"./tests/data/analogs.xlsx\" analogs = Analogs . from_excel ( data_path , header = 3 , first_row = 5 , first_column = 2 ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"A\" ] analogs = Analogs . from_excel ( data_path , header = 3 , first_row = 5 , first_column = 2 , usecols = channels ) Or by position: channels = [ 1 ] analogs = Analogs . from_excel ( data_path , header = 3 , first_row = 5 , first_column = 2 , usecols = channels ) It is also possible to specify a column containing the time vector: analogs = Analogs . from_excel ( data_path , header = 3 , first_row = 5 , first_column = 1 , time_column = 0 ) Source code in pyomeca/analogs.py @classmethod def from_excel ( cls , filename : Union [ str , Path ], sheet_name : Union [ str , int ] = 0 , usecols : Optional [ List [ Union [ str , int ]]] = None , header : Optional [ int ] = None , first_row : int = 0 , first_column : Optional [ Union [ str , int ]] = None , time_column : Optional [ Union [ str , int ]] = None , trailing_columns : Optional [ Union [ str , int ]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , skip_rows : Optional [ List [ int ]] = None , pandas_kwargs : Optional [ dict ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Analogs DataArray from a excel file. Arguments: filename: Any valid string path sheet_name: Strings are used for sheet names. Integers are used in zero-indexed sheet positions usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz'] header: Row of the header (0-indexed) first_row: First row of the data (0-indexed) first_column: First column of the data (0-indexed) time_column: Location of the time column. If None, indices are associated trailing_columns: If for some reason the csv reads extra columns, how many should be ignored prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) skip_rows: Line numbers to skip (0-indexed) pandas_kwargs: Keyword arguments to be passed to `pandas.read_excel` attrs: attrs to be passed to `xr.DataArray`. If attrs['rate'] is provided, compute the time accordingly Returns: Analogs `xarray.DataArray` with the specified data and coordinates !!! example To read [this excel file](https://github.com/pyomeca/pyomeca/blob/master/tests/data/analogs.xlsx), type: ```python from pyomeca import Analogs data_path = \"./tests/data/analogs.xlsx\" analogs = Analogs.from_excel(data_path, header=3, first_row=5, first_column=2) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"A\"] analogs = Analogs.from_excel( data_path, header=3, first_row=5, first_column=2, usecols=channels ) ``` Or by position: ```python channels = [1] analogs = Analogs.from_excel( data_path, header=3, first_row=5, first_column=2, usecols=channels ) ``` It is also possible to specify a column containing the time vector: ```python analogs = Analogs.from_excel( data_path, header=3, first_row=5, first_column=1, time_column=0 ) ``` \"\"\" return read . read_csv_or_excel ( cls , \"excel\" , filename , usecols , header , first_row , first_column , time_column , trailing_columns , prefix_delimiter , suffix_delimiter , skip_rows , pandas_kwargs , attrs , sheet_name , )","title":"from_excel()"},{"location":"api/analogs/#pyomeca.analogs.Analogs.from_mot","text":"Analogs DataArray from a mot file. Parameters: Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required end_header Optional[bool] Index where endheader appears (0 indexed). If not provided, the index is automatically determined. None kwargs Keyword arguments to be passed to from_csv {} Returns: Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates Example To read this mot file , type: from pyomeca import Analogs data_path = \"./tests/data/inverse_kin.mot\" analogs = Analogs . from_mot ( data_path ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"elbow_flexion\" , \"pro_sup\" ] analogs = Analogs . from_mot ( data_path , usecols = channels ) Or by position: channels = [ 3 , 4 ] analogs = Analogs . from_mot ( data_path , usecols = channels ) Source code in pyomeca/analogs.py @classmethod def from_mot ( cls , filename : Union [ str , Path ], end_header : Optional [ bool ] = None , ** kwargs ) -> xr . DataArray : \"\"\" Analogs DataArray from a mot file. Arguments: filename: Any valid string path end_header: Index where `endheader` appears (0 indexed). If not provided, the index is automatically determined. kwargs: Keyword arguments to be passed to `from_csv` Returns: Analogs `xarray.DataArray` with the specified data and coordinates !!! example To read [this mot file](https://github.com/pyomeca/pyomeca/blob/master/tests/data/inverse_kin.mot), type: ```python from pyomeca import Analogs data_path = \"./tests/data/inverse_kin.mot\" analogs = Analogs.from_mot(data_path) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"elbow_flexion\", \"pro_sup\"] analogs = Analogs.from_mot(data_path, usecols=channels) ``` Or by position: ```python channels = [3, 4] analogs = Analogs.from_mot(data_path, usecols=channels) ``` \"\"\" return read . read_sto_or_mot ( cls , filename , end_header , ** kwargs )","title":"from_mot()"},{"location":"api/analogs/#pyomeca.analogs.Analogs.from_random_data","text":"Create random data from a specified distribution (normal by default) using random walk. Parameters: Name Type Description Default distribution str Distribution available in numpy.random 'normal' size tuple Shape of the desired array (10, 100) kwargs Keyword argument(s) to be passed to numpy.random. distribution {} Returns: Type Description DataArray Random Analogs xarray.DataArray sampled from a given distribution Example To instantiate an Analogs with some random data sampled from a normal distribution: from pyomeca import Analogs n_channels = 10 n_frames = 100 size = n_channels , n_frames analogs = Analogs . from_random_data ( size = size ) You can choose any distribution available in numpy.random : analogs = Analogs . from_random_data ( distribution = \"uniform\" , size = size , low = 1 , high = 10 ) Source code in pyomeca/analogs.py @classmethod def from_random_data ( cls , distribution : str = \"normal\" , size : tuple = ( 10 , 100 ), ** kwargs ) -> xr . DataArray : \"\"\" Create random data from a specified distribution (normal by default) using random walk. Arguments: distribution: Distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions) size: Shape of the desired array kwargs: Keyword argument(s) to be passed to numpy.random.`distribution` Returns: Random Analogs `xarray.DataArray` sampled from a given distribution !!! example To instantiate an `Analogs` with some random data sampled from a normal distribution: ```python from pyomeca import Analogs n_channels = 10 n_frames = 100 size = n_channels, n_frames analogs = Analogs.from_random_data(size=size) ``` You can choose any distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions): ```python analogs = Analogs.from_random_data(distribution=\"uniform\", size=size, low=1, high=10) ``` \"\"\" return Analogs ( getattr ( np . random , distribution )( size = size , ** kwargs ) . cumsum ( - 1 ))","title":"from_random_data()"},{"location":"api/analogs/#pyomeca.analogs.Analogs.from_sto","text":"Analogs DataArray from a sto file. Parameters: Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required end_header Optional[bool] Index where endheader appears (0 indexed). If not provided, the index is automatically determined None kwargs Keyword arguments to be passed to from_csv {} Returns: Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates Example To read this sto file , type: from pyomeca import Analogs data_path = \"./tests/data/inverse_dyn.sto\" analogs = Analogs . from_sto ( data_path ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"shoulder_plane_moment\" , \"shoulder_ele_moment\" ] analogs = Analogs . from_sto ( data_path , usecols = channels ) Or by position: channels = [ 3 , 4 ] analogs = Analogs . from_sto ( data_path , usecols = channels ) Source code in pyomeca/analogs.py @classmethod def from_sto ( cls , filename : Union [ str , Path ], end_header : Optional [ bool ] = None , ** kwargs ) -> xr . DataArray : \"\"\" Analogs DataArray from a sto file. Arguments: filename: Any valid string path end_header: Index where `endheader` appears (0 indexed). If not provided, the index is automatically determined kwargs: Keyword arguments to be passed to `from_csv` Returns: Analogs `xarray.DataArray` with the specified data and coordinates !!! example To read [this sto file](https://github.com/pyomeca/pyomeca/blob/master/tests/data/inverse_dyn.sto), type: ```python from pyomeca import Analogs data_path = \"./tests/data/inverse_dyn.sto\" analogs = Analogs.from_sto(data_path) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"shoulder_plane_moment\", \"shoulder_ele_moment\"] analogs = Analogs.from_sto(data_path, usecols=channels) ``` Or by position: ```python channels = [3, 4] analogs = Analogs.from_sto(data_path, usecols=channels) ``` \"\"\" return read . read_sto_or_mot ( cls , filename , end_header , ** kwargs )","title":"from_sto()"},{"location":"api/angles/","text":"angles.py Angles __new__ ( cls , data = None , time = None , ** kwargs ) special staticmethod Angles DataArray with axis , channel and time dimensions used for joint angles. Parameters: Name Type Description Default data Optional[Union[<built-in function array>, numpy.ndarray, xarray.core.dataarray.DataArray]] Array to be passed to xarray.DataArray None time Optional[Union[<built-in function array>, list, pandas.core.series.Series]] Time vector in seconds associated with the data parameter None kwargs Keyword argument(s) to be passed to xarray.DataArray {} Returns: Type Description DataArray Angles xarray.DataArray with the specified data and coordinates Example To instantiate an Angles 3 by 3 and 100 frames filled with some random data: import numpy as np from pyomeca import Angles n_axis = 3 n_channel = 4 n_frames = 100 data = np . random . random ( size = ( n_axis , n_channel , n_frames )) angles = Angles ( data ) You can an associate time vector: rate = 100 # Hz time = np . arange ( start = 0 , stop = n_frames / rate , step = 1 / rate ) angles = Angles ( data , time = time ) Note Calling Angles() generate an empty array. Source code in pyomeca/angles.py def __new__ ( cls , data : Optional [ Union [ np . array , np . ndarray , xr . DataArray ]] = None , time : Optional [ Union [ np . array , list , pd . Series ]] = None , ** kwargs , ) -> xr . DataArray : \"\"\" Angles DataArray with `axis`, `channel` and `time` dimensions used for joint angles. ![angles](/images/objects/angles.svg) Arguments: data: Array to be passed to xarray.DataArray time: Time vector in seconds associated with the `data` parameter kwargs: Keyword argument(s) to be passed to xarray.DataArray Returns: Angles `xarray.DataArray` with the specified data and coordinates !!! example To instantiate an `Angles` 3 by 3 and 100 frames filled with some random data: ```python import numpy as np from pyomeca import Angles n_axis = 3 n_channel = 4 n_frames = 100 data = np.random.random(size=(n_axis, n_channel, n_frames)) angles = Angles(data) ``` You can an associate time vector: ```python rate = 100 # Hz time = np.arange(start=0, stop=n_frames / rate, step=1 / rate) angles = Angles(data, time=time) ``` !!! note Calling `Angles()` generate an empty array. \"\"\" coords = {} if data is None : data = np . ndarray (( 0 , 0 , 0 )) if time is not None : coords [ \"time\" ] = time return xr . DataArray ( data = data , dims = ( \"axis\" , \"channel\" , \"time\" ), coords = coords , name = \"angles\" , ** kwargs , ) from_random_data ( distribution = 'normal' , size = ( 3 , 10 , 100 ), ** kwargs ) classmethod Create random data from a specified distribution (normal by default) using random walk. Parameters: Name Type Description Default distribution str Distribution available in numpy.random 'normal' size tuple Shape of the desired array (3, 10, 100) kwargs Keyword argument(s) to be passed to numpy.random. distribution {} Returns: Type Description DataArray Random angles xarray.DataArray sampled from a given distribution Example To instantiate an Angles with some random data sampled from a normal distribution: from pyomeca import Angles n_frames = 100 size = 3 , 10 , n_frames angles = Angles . from_random_data ( size = size ) You can choose any distribution available in numpy.random : angles = Angles . from_random_data ( distribution = \"uniform\" , size = size , low = 1 , high = 10 ) Source code in pyomeca/angles.py @classmethod def from_random_data ( cls , distribution : str = \"normal\" , size : tuple = ( 3 , 10 , 100 ), ** kwargs ) -> xr . DataArray : \"\"\" Create random data from a specified distribution (normal by default) using random walk. Arguments: distribution: Distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions) size: Shape of the desired array kwargs: Keyword argument(s) to be passed to numpy.random.`distribution` Returns: Random angles `xarray.DataArray` sampled from a given distribution !!! example To instantiate an `Angles` with some random data sampled from a normal distribution: ```python from pyomeca import Angles n_frames = 100 size = 3, 10, n_frames angles = Angles.from_random_data(size=size) ``` You can choose any distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions): ```python angles = Angles.from_random_data(distribution=\"uniform\", size=size, low=1, high=10) ``` \"\"\" return Angles ( getattr ( np . random , distribution )( size = size , ** kwargs ) . cumsum ( - 1 )) from_rototrans ( rt , angle_sequence ) classmethod Angles DataArray from a rototranslation matrix and specified angle sequence. Parameters: Name Type Description Default rt DataArray Rototranslation matrix created with pyomeca.Rototrans() required angle_sequence str Euler sequence of angles. Valid values are all permutations of \"xyz\" required Returns: Type Description DataArray Angles xarray.DataArray from the specified rototrans and angles sequence Example To get the euler angles from a random rototranslation matrix with a given angle sequence type: from pyomeca import Angles , Rototrans size = ( 4 , 4 , 100 ) rt = Rototrans . from_random_data ( size = size ) angles_sequence = \"xyz\" angles = Angles . from_rototrans ( rt , angles_sequence ) Source code in pyomeca/angles.py @classmethod def from_rototrans ( cls , rt : xr . DataArray , angle_sequence : str ) -> xr . DataArray : \"\"\" Angles DataArray from a rototranslation matrix and specified angle sequence. Arguments: rt: Rototranslation matrix created with pyomeca.Rototrans() angle_sequence: Euler sequence of angles. Valid values are all permutations of \"xyz\" Returns: Angles `xarray.DataArray` from the specified rototrans and angles sequence !!! example To get the euler angles from a random rototranslation matrix with a given angle sequence type: ```python from pyomeca import Angles, Rototrans size = (4, 4, 100) rt = Rototrans.from_random_data(size=size) angles_sequence = \"xyz\" angles = Angles.from_rototrans(rt, angles_sequence) ``` \"\"\" return angles . angles_from_rototrans ( cls , rt , angle_sequence )","title":"Angles"},{"location":"api/angles/#anglespy","text":"","title":"angles.py"},{"location":"api/angles/#pyomeca.angles","text":"","title":"pyomeca.angles"},{"location":"api/angles/#pyomeca.angles.Angles","text":"","title":"Angles"},{"location":"api/angles/#pyomeca.angles.Angles.__new__","text":"Angles DataArray with axis , channel and time dimensions used for joint angles. Parameters: Name Type Description Default data Optional[Union[<built-in function array>, numpy.ndarray, xarray.core.dataarray.DataArray]] Array to be passed to xarray.DataArray None time Optional[Union[<built-in function array>, list, pandas.core.series.Series]] Time vector in seconds associated with the data parameter None kwargs Keyword argument(s) to be passed to xarray.DataArray {} Returns: Type Description DataArray Angles xarray.DataArray with the specified data and coordinates Example To instantiate an Angles 3 by 3 and 100 frames filled with some random data: import numpy as np from pyomeca import Angles n_axis = 3 n_channel = 4 n_frames = 100 data = np . random . random ( size = ( n_axis , n_channel , n_frames )) angles = Angles ( data ) You can an associate time vector: rate = 100 # Hz time = np . arange ( start = 0 , stop = n_frames / rate , step = 1 / rate ) angles = Angles ( data , time = time ) Note Calling Angles() generate an empty array. Source code in pyomeca/angles.py def __new__ ( cls , data : Optional [ Union [ np . array , np . ndarray , xr . DataArray ]] = None , time : Optional [ Union [ np . array , list , pd . Series ]] = None , ** kwargs , ) -> xr . DataArray : \"\"\" Angles DataArray with `axis`, `channel` and `time` dimensions used for joint angles. ![angles](/images/objects/angles.svg) Arguments: data: Array to be passed to xarray.DataArray time: Time vector in seconds associated with the `data` parameter kwargs: Keyword argument(s) to be passed to xarray.DataArray Returns: Angles `xarray.DataArray` with the specified data and coordinates !!! example To instantiate an `Angles` 3 by 3 and 100 frames filled with some random data: ```python import numpy as np from pyomeca import Angles n_axis = 3 n_channel = 4 n_frames = 100 data = np.random.random(size=(n_axis, n_channel, n_frames)) angles = Angles(data) ``` You can an associate time vector: ```python rate = 100 # Hz time = np.arange(start=0, stop=n_frames / rate, step=1 / rate) angles = Angles(data, time=time) ``` !!! note Calling `Angles()` generate an empty array. \"\"\" coords = {} if data is None : data = np . ndarray (( 0 , 0 , 0 )) if time is not None : coords [ \"time\" ] = time return xr . DataArray ( data = data , dims = ( \"axis\" , \"channel\" , \"time\" ), coords = coords , name = \"angles\" , ** kwargs , )","title":"__new__()"},{"location":"api/angles/#pyomeca.angles.Angles.from_random_data","text":"Create random data from a specified distribution (normal by default) using random walk. Parameters: Name Type Description Default distribution str Distribution available in numpy.random 'normal' size tuple Shape of the desired array (3, 10, 100) kwargs Keyword argument(s) to be passed to numpy.random. distribution {} Returns: Type Description DataArray Random angles xarray.DataArray sampled from a given distribution Example To instantiate an Angles with some random data sampled from a normal distribution: from pyomeca import Angles n_frames = 100 size = 3 , 10 , n_frames angles = Angles . from_random_data ( size = size ) You can choose any distribution available in numpy.random : angles = Angles . from_random_data ( distribution = \"uniform\" , size = size , low = 1 , high = 10 ) Source code in pyomeca/angles.py @classmethod def from_random_data ( cls , distribution : str = \"normal\" , size : tuple = ( 3 , 10 , 100 ), ** kwargs ) -> xr . DataArray : \"\"\" Create random data from a specified distribution (normal by default) using random walk. Arguments: distribution: Distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions) size: Shape of the desired array kwargs: Keyword argument(s) to be passed to numpy.random.`distribution` Returns: Random angles `xarray.DataArray` sampled from a given distribution !!! example To instantiate an `Angles` with some random data sampled from a normal distribution: ```python from pyomeca import Angles n_frames = 100 size = 3, 10, n_frames angles = Angles.from_random_data(size=size) ``` You can choose any distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions): ```python angles = Angles.from_random_data(distribution=\"uniform\", size=size, low=1, high=10) ``` \"\"\" return Angles ( getattr ( np . random , distribution )( size = size , ** kwargs ) . cumsum ( - 1 ))","title":"from_random_data()"},{"location":"api/angles/#pyomeca.angles.Angles.from_rototrans","text":"Angles DataArray from a rototranslation matrix and specified angle sequence. Parameters: Name Type Description Default rt DataArray Rototranslation matrix created with pyomeca.Rototrans() required angle_sequence str Euler sequence of angles. Valid values are all permutations of \"xyz\" required Returns: Type Description DataArray Angles xarray.DataArray from the specified rototrans and angles sequence Example To get the euler angles from a random rototranslation matrix with a given angle sequence type: from pyomeca import Angles , Rototrans size = ( 4 , 4 , 100 ) rt = Rototrans . from_random_data ( size = size ) angles_sequence = \"xyz\" angles = Angles . from_rototrans ( rt , angles_sequence ) Source code in pyomeca/angles.py @classmethod def from_rototrans ( cls , rt : xr . DataArray , angle_sequence : str ) -> xr . DataArray : \"\"\" Angles DataArray from a rototranslation matrix and specified angle sequence. Arguments: rt: Rototranslation matrix created with pyomeca.Rototrans() angle_sequence: Euler sequence of angles. Valid values are all permutations of \"xyz\" Returns: Angles `xarray.DataArray` from the specified rototrans and angles sequence !!! example To get the euler angles from a random rototranslation matrix with a given angle sequence type: ```python from pyomeca import Angles, Rototrans size = (4, 4, 100) rt = Rototrans.from_random_data(size=size) angles_sequence = \"xyz\" angles = Angles.from_rototrans(rt, angles_sequence) ``` \"\"\" return angles . angles_from_rototrans ( cls , rt , angle_sequence )","title":"from_rototrans()"},{"location":"api/dataarray_accessor/","text":"dataarray_accessor.py DataArrayAccessor Meca DataArray accessor used for processing or file writing. abs ( self ) Calculate the absolute value element-wise. Returns: Type Description DataArray A xarray.DataArray containing the absolute of each element Example To compute the absolute value of any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from pyomeca import Analogs analogs = Analogs . from_random_data () analogs . meca . abs () Source code in pyomeca/dataarray_accessor.py def abs ( self ) -> xr . DataArray : \"\"\" Calculate the absolute value element-wise. Returns: A `xarray.DataArray` containing the absolute of each element !!! example To compute the absolute value of any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from pyomeca import Analogs analogs = Analogs.from_random_data() analogs.meca.abs() ``` \"\"\" return matrix . abs_ ( self . _obj ) band_pass ( self , order , cutoff , freq = None ) Band-pass Butterworth filter. Parameters: Name Type Description Default order int Order of the filter required cutoff Union[list, tuple, <built-in function array>] Cut-off frequency such as (lower, upper) required freq Optional[Union[int, float]] Sampling frequency. Optional if attrs[\"rate\"] is specified. None Returns: Type Description DataArray A band-pass filtered xarray.DataArray Example To band-pass any xarray.DataArray (including Analogs, Angles, Markers or Rototrans) signal at 10-200Hz: import matplotlib.pyplot as plt import numpy as np from pyomeca import Analogs fake_emg = np . random . uniform ( low =- 1 , high = 1 , size = ( 1 , 1000 )) analogs = Analogs ( fake_emg ) freq = 1000 # Hz band_pass = analogs . meca . band_pass ( order = 2 , cutoff = [ 10 , 200 ], freq = freq ) analogs . plot ( label = \"raw\" ) band_pass . plot ( label = \"band-pass @ 10-200Hz\" ) plt . legend () plt . show () Source code in pyomeca/dataarray_accessor.py def band_pass ( self , order : int , cutoff : Union [ list , tuple , np . array ], freq : Optional [ Union [ int , float ]] = None , ) -> xr . DataArray : \"\"\" Band-pass Butterworth filter. Arguments: order: Order of the filter cutoff: Cut-off frequency such as (lower, upper) freq: Sampling frequency. Optional if attrs[\"rate\"] is specified. Returns: A band-pass filtered `xarray.DataArray` !!! example To band-pass any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans) signal at 10-200Hz: ```python import matplotlib.pyplot as plt import numpy as np from pyomeca import Analogs fake_emg = np.random.uniform(low=-1, high=1, size=(1, 1000)) analogs = Analogs(fake_emg) freq = 1000 # Hz band_pass = analogs.meca.band_pass(order=2, cutoff=[10, 200], freq=freq) analogs.plot(label=\"raw\") band_pass.plot(label=\"band-pass @ 10-200Hz\") plt.legend() plt.show() ``` ![band_pass](/images/api/band_pass.svg) \"\"\" return filter . band_pass ( self . _obj , order , cutoff , freq ) band_stop ( self , order , cutoff , freq = None ) Band-stop Butterworth filter. Parameters: Name Type Description Default order int Order of the filter required cutoff Union[list, tuple, <built-in function array>] Cut-off frequency such as (lower, upper) required freq Optional[Union[int, float]] Sampling frequency. Optional if attrs[\"rate\"] is specified. None Returns: Type Description DataArray A band-stop filtered xarray.DataArray Example To band-stop any xarray.DataArray (including Analogs, Angles, Markers or Rototrans) signal at 40-60Hz: import matplotlib.pyplot as plt import numpy as np from pyomeca import Analogs fake_emg = np . random . uniform ( low =- 1 , high = 1 , size = ( 1 , 1000 )) analogs = Analogs ( fake_emg ) freq = 1000 # Hz band_stop = analogs . meca . band_stop ( order = 2 , cutoff = [ 40 , 60 ], freq = freq ) analogs . plot ( label = \"raw\" ) band_stop . plot ( label = \"band-stop @ 40-60Hz\" ) plt . legend () plt . show () Note You can also perform a notch filter with this method. A notch filter is a band-stop filter with a narrow bandwidth. It rejects a narrow frequency band and leaves the rest of the spectrum little changed. Source code in pyomeca/dataarray_accessor.py def band_stop ( self , order : int , cutoff : Union [ list , tuple , np . array ], freq : Optional [ Union [ int , float ]] = None , ) -> xr . DataArray : \"\"\" Band-stop Butterworth filter. Arguments: order: Order of the filter cutoff: Cut-off frequency such as (lower, upper) freq: Sampling frequency. Optional if attrs[\"rate\"] is specified. Returns: A band-stop filtered `xarray.DataArray` !!! example To band-stop any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans) signal at 40-60Hz: ```python import matplotlib.pyplot as plt import numpy as np from pyomeca import Analogs fake_emg = np.random.uniform(low=-1, high=1, size=(1, 1000)) analogs = Analogs(fake_emg) freq = 1000 # Hz band_stop = analogs.meca.band_stop(order=2, cutoff=[40, 60], freq=freq) analogs.plot(label=\"raw\") band_stop.plot(label=\"band-stop @ 40-60Hz\") plt.legend() plt.show() ``` ![band_stop](/images/api/band_stop.svg) !!! note You can also perform a notch filter with this method. A notch filter is a band-stop filter with a narrow bandwidth. It rejects a narrow frequency band and leaves the rest of the spectrum little changed. \"\"\" return filter . band_stop ( self . _obj , order , cutoff , freq ) center ( self , mu = None ) Center an array (i.e., subtract the mean). Parameters: Name Type Description Default mu Union[xarray.core.dataarray.DataArray, <built-in function array>, float, int] the value to be subtracted. If unspecified, take the mean along the time axis. None Returns: Type Description DataArray a xarray.DataArray containing the root-mean-square of the matrix Example To center any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): import numpy as np from pyomeca import Analogs random_data = np . random . uniform ( low = 2 , high = 4 , size = ( 1 , 100 )) analogs = Analogs ( random_data ) centered = analogs . meca . center () This will substract the mean of the signal by default. The previous random signal was sampled from a uniform distribution from 2 and 4 (mean around 3). When centered, the signal is now center around 0 (mean around 0). import matplotlib.pyplot as plt analogs . plot ( label = \"raw\" ) centered . plot ( label = \"centered\" ) plt . legend () plt . show () Source code in pyomeca/dataarray_accessor.py def center ( self , mu : Union [ xr . DataArray , np . array , float , int ] = None ) -> xr . DataArray : \"\"\" Center an array (i.e., subtract the mean). Arguments: mu: the value to be subtracted. If unspecified, take the mean along the time axis. Returns: a `xarray.DataArray` containing the root-mean-square of the matrix !!! example To center any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python import numpy as np from pyomeca import Analogs random_data = np.random.uniform(low=2, high=4, size=(1, 100)) analogs = Analogs(random_data) centered = analogs.meca.center() ``` This will substract the mean of the signal by default. The previous random signal was sampled from a uniform distribution from 2 and 4 (mean around 3). When centered, the signal is now center around 0 (mean around 0). ```python import matplotlib.pyplot as plt analogs.plot(label=\"raw\") centered.plot(label=\"centered\") plt.legend() plt.show() ``` ![center](/images/api/center.svg) \"\"\" return matrix . center ( self . _obj , mu ) detect_onset ( self , threshold , n_above = 1 , n_below = 0 , threshold2 = None , n_above2 = 1 ) Detects onset based on amplitude threshold. Parameters: Name Type Description Default threshold Union[float, int] minimum amplitude to detect required n_above int minimum number of continuous samples >= threshold to detect 1 n_below int minimum number of continuous samples below threshold that will be ignored in the detection of x >= threshold 0 threshold2 int minimum amplitude of n_above2 values in x to detect None n_above2 int minimum number of samples >= threshold2 to detect 1 Note You might have to tune the parameters according to the signal-to-noise characteristic of the data. Returns: Type Description <built-in function array> inds: 1D array_like [indi, indf] containing initial and final indexes of the onset events Example To detect the onsets of any one-dimensional xarray.DataArray (including Analogs, Angles, Markers or Rototrans): import matplotlib.pyplot as plt import numpy as np import scipy.signal as sig from pyomeca import Analogs # simulate fake ecg data rr = 2.5 # rr time in seconds freq = 100 # sampling rate pqrst = sig . resample ( sig . wavelets . daub ( 10 ), int ( rr * freq )) ecg = np . concatenate ([ pqrst , pqrst , pqrst ]) . reshape ( 1 , - 1 ) analogs = Analogs ( ecg ) analogs . plot () onsets = analogs . sel ( channel = 0 ) . meca . detect_onset ( threshold = analogs . mean (), # mean of the signal n_above = freq / 2 , # we want at least 1/2 second above the threshold n_below = freq / 2 , # we accept point below threshold for 1/2 second ) for ( start , end ) in onsets : plt . axvline ( x = start , color = \"g\" ) plt . axvline ( x = end , color = \"r\" ) plt . show () Warning detect_onset works only for 1-dimensional data. For example, you can select a dimension using analogs.sel(channel='EMG1') or analogs.isel(channel=0) . Source code in pyomeca/dataarray_accessor.py def detect_onset ( self , threshold : Union [ float , int ], n_above : int = 1 , n_below : int = 0 , threshold2 : int = None , n_above2 : int = 1 , ) -> np . array : \"\"\" Detects onset based on amplitude threshold. Arguments: threshold: minimum amplitude to detect n_above: minimum number of continuous samples >= `threshold` to detect n_below: minimum number of continuous samples below `threshold` that will be ignored in the detection of `x` >= `threshold` threshold2: minimum amplitude of `n_above2` values in `x` to detect n_above2: minimum number of samples >= `threshold2` to detect Note: You might have to tune the parameters according to the signal-to-noise characteristic of the data. Returns: inds: 1D array_like [indi, indf] containing initial and final indexes of the onset events !!! example To detect the onsets of any __one-dimensional__ `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python import matplotlib.pyplot as plt import numpy as np import scipy.signal as sig from pyomeca import Analogs # simulate fake ecg data rr = 2.5 # rr time in seconds freq = 100 # sampling rate pqrst = sig.resample(sig.wavelets.daub(10), int(rr * freq)) ecg = np.concatenate([pqrst, pqrst, pqrst]).reshape(1, -1) analogs = Analogs(ecg) analogs.plot() onsets = analogs.sel(channel=0).meca.detect_onset( threshold=analogs.mean(), # mean of the signal n_above=freq / 2, # we want at least 1/2 second above the threshold n_below=freq / 2, # we accept point below threshold for 1/2 second ) for (start, end) in onsets: plt.axvline(x=start, color=\"g\") plt.axvline(x=end, color=\"r\") plt.show() ``` ![detect_onset](/images/api/detect_onset.svg) !!! warning `detect_onset` works only for 1-dimensional data. For example, you can select a dimension using `analogs.sel(channel='EMG1')` or `analogs.isel(channel=0)`. \"\"\" return misc . detect_onset ( self . _obj , threshold , n_above , n_below , threshold2 , n_above2 ) detect_outliers ( self , threshold = 3 ) Detects data points that are threshold times the standard deviation from the mean. Parameters: Name Type Description Default threshold int Multiple of standard deviation from which data is considered outlier 3 Returns: Type Description DataArray A boolean xarray.DataArray containing the outliers Example To get a boolean xr.DataArray containing the data that are 3 times the mean +/- standard deviation: from pyomeca import Analogs analogs = Analogs . from_random_data () outliers = analogs . meca . detect_outliers ( threshold = 1 ) Let's plot the data that are 1 time the mean +/- standard deviation on an analog vector: import matplotlib.pyplot as plt analogs = Analogs . from_random_data ( size = ( 1 , 100 )) threshold = 1 outliers = analogs . meca . detect_outliers ( threshold = threshold ) analogs . plot . line ( x = \"time\" , color = \"black\" , add_legend = False ) analogs . where ( outliers ) . plot . line ( x = \"time\" , color = \"red\" , add_legend = False , marker = \"o\" , label = \"outliers\" ) mu = analogs . mean () sigma = analogs . std () plt . axhline ( mu , color = \"grey\" ) plt . axhspan ( mu - threshold * sigma , mu + threshold * sigma , color = \"grey\" , alpha = 0.3 , label = f \"mean +/- { threshold } std\" , ) plt . legend () plt . show () Note detect_outliers is not limited on one-dimensional data and can detect outliers for any number of dimensions. Source code in pyomeca/dataarray_accessor.py def detect_outliers ( self , threshold : int = 3 ) -> xr . DataArray : \"\"\" Detects data points that are `threshold` times the standard deviation from the mean. Arguments: threshold: Multiple of standard deviation from which data is considered outlier Returns: A boolean `xarray.DataArray` containing the outliers !!! example To get a boolean `xr.DataArray` containing the data that are 3 times the mean +/- standard deviation: ```python from pyomeca import Analogs analogs = Analogs.from_random_data() outliers = analogs.meca.detect_outliers(threshold=1) ``` Let's plot the data that are 1 time the mean +/- standard deviation on an analog vector: ```python import matplotlib.pyplot as plt analogs = Analogs.from_random_data(size=(1, 100)) threshold = 1 outliers = analogs.meca.detect_outliers(threshold=threshold) analogs.plot.line(x=\"time\", color=\"black\", add_legend=False) analogs.where(outliers).plot.line( x=\"time\", color=\"red\", add_legend=False, marker=\"o\", label=\"outliers\" ) mu = analogs.mean() sigma = analogs.std() plt.axhline(mu, color=\"grey\") plt.axhspan( mu - threshold * sigma, mu + threshold * sigma, color=\"grey\", alpha=0.3, label=f\"mean +/- {threshold} std\", ) plt.legend() plt.show() ``` ![detect_outliers](/images/api/detect_outliers.svg) Note: `detect_outliers` is not limited on one-dimensional data and can detect outliers for any number of dimensions. \"\"\" return misc . detect_outliers ( self . _obj , threshold ) fft ( self , freq , only_positive = True ) Performs a discrete Fourier Transform and return a DataArray with the corresponding amplitudes and frequencies. Parameters: Name Type Description Default freq Union[int, float] Sampling frequency (usually stored in array.attrs[\"rate\"] ) required only_positive bool If True , returns only the positive frequencies True Returns: Type Description DataArray A xarray.DataArray with the corresponding amplitudes and frequencies Example Let's compare the resulting fft on a raw and low-passed signal: import matplotlib.pyplot as plt import numpy as np from pyomeca import Analogs # generate fake data freq = 100 time = np . arange ( 0 , 1 , 0.01 ) w = 2 * np . pi y = np . sin ( w * time ) + 0.1 * np . sin ( 10 * w * time ) analogs = Analogs ( y . reshape ( 1 , - 1 )) analogs_low_passed = analogs . meca . low_pass ( order = 2 , cutoff = 5 , freq = freq ) # compute fft on raw and low-passed signal fft_raw = analogs . meca . fft ( freq = freq ) fft_low_passed = analogs_low_passed . meca . fft ( freq = freq ) fig , ax = plt . subplots ( ncols = 2 , figsize = ( 10 , 4 )) # plot signal vs. time analogs . plot . line ( x = \"time\" , ax = ax [ 0 ], color = \"black\" , add_legend = False ) analogs_low_passed . plot . line ( x = \"time\" , ax = ax [ 0 ], color = \"red\" , add_legend = False ) ax [ 0 ] . set_title ( \"Signal vs. Time\" ) # plot amplitudes vs. frequencies fft_raw . plot . line ( x = \"freq\" , ax = ax [ 1 ], color = \"black\" , label = \"raw\" ) fft_low_passed . plot . line ( x = \"freq\" , ax = ax [ 1 ], color = \"red\" , label = \"low-pass @ 5Hz\" ) ax [ 1 ] . set_title ( \"Amplitudes vs. Freq\" ) plt . legend () plt . show () Source code in pyomeca/dataarray_accessor.py def fft ( self , freq : Union [ int , float ], only_positive : bool = True ) -> xr . DataArray : \"\"\" Performs a discrete Fourier Transform and return a DataArray with the corresponding amplitudes and frequencies. Arguments: freq: Sampling frequency (usually stored in `array.attrs[\"rate\"]`) only_positive: If `True`, returns only the positive frequencies Returns: A `xarray.DataArray` with the corresponding amplitudes and frequencies !!! example Let's compare the resulting fft on a raw and low-passed signal: ```python import matplotlib.pyplot as plt import numpy as np from pyomeca import Analogs # generate fake data freq = 100 time = np.arange(0, 1, 0.01) w = 2 * np.pi y = np.sin(w * time) + 0.1 * np.sin(10 * w * time) analogs = Analogs(y.reshape(1, -1)) analogs_low_passed = analogs.meca.low_pass(order=2, cutoff=5, freq=freq) # compute fft on raw and low-passed signal fft_raw = analogs.meca.fft(freq=freq) fft_low_passed = analogs_low_passed.meca.fft(freq=freq) fig, ax = plt.subplots(ncols=2, figsize=(10, 4)) # plot signal vs. time analogs.plot.line(x=\"time\", ax=ax[0], color=\"black\", add_legend=False) analogs_low_passed.plot.line(x=\"time\", ax=ax[0], color=\"red\", add_legend=False) ax[0].set_title(\"Signal vs. Time\") # plot amplitudes vs. frequencies fft_raw.plot.line(x=\"freq\", ax=ax[1], color=\"black\", label=\"raw\") fft_low_passed.plot.line(x=\"freq\", ax=ax[1], color=\"red\", label=\"low-pass @ 5Hz\") ax[1].set_title(\"Amplitudes vs. Freq\") plt.legend() plt.show() ``` ![fft](/images/api/fft.svg) \"\"\" return misc . fft ( self . _obj , freq , only_positive ) high_pass ( self , order , cutoff , freq = None ) High-pass Butterworth filter. Parameters: Name Type Description Default order int Order of the filter required cutoff Union[int, float, <built-in function array>] Cut-off frequency required freq Optional[Union[int, float]] Sampling frequency. Optional if attrs[\"rate\"] is specified. None Returns: Type Description DataArray A high-pass filtered xarray.DataArray Example To high-pass any xarray.DataArray (including Analogs, Angles, Markers or Rototrans) signal at 100Hz: import matplotlib.pyplot as plt import numpy as np from pyomeca import Analogs fake_emg = np . random . uniform ( low =- 1 , high = 1 , size = ( 1 , 1000 )) analogs = Analogs ( fake_emg ) freq = 1000 # Hz high_pass = analogs . meca . high_pass ( order = 2 , cutoff = 100 , freq = freq ) analogs . plot ( label = \"raw\" ) high_pass . plot ( label = \"high-pass @ 100Hz\" ) plt . legend () plt . show () Source code in pyomeca/dataarray_accessor.py def high_pass ( self , order : int , cutoff : Union [ int , float , np . array ], freq : Optional [ Union [ int , float ]] = None , ) -> xr . DataArray : \"\"\" High-pass Butterworth filter. Arguments: order: Order of the filter cutoff: Cut-off frequency freq: Sampling frequency. Optional if attrs[\"rate\"] is specified. Returns: A high-pass filtered `xarray.DataArray` !!! example To high-pass any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans) signal at 100Hz: ```python import matplotlib.pyplot as plt import numpy as np from pyomeca import Analogs fake_emg = np.random.uniform(low=-1, high=1, size=(1, 1000)) analogs = Analogs(fake_emg) freq = 1000 # Hz high_pass = analogs.meca.high_pass(order=2, cutoff=100, freq=freq) analogs.plot(label=\"raw\") high_pass.plot(label=\"high-pass @ 100Hz\") plt.legend() plt.show() ``` ![high_pass](/images/api/high_pass.svg) \"\"\" return filter . high_pass ( self . _obj , order , cutoff , freq ) low_pass ( self , order , cutoff , freq = None ) Low-pass Butterworth filter. Parameters: Name Type Description Default order int Order of the filter required cutoff Union[int, float, <built-in function array>] Cut-off frequency required freq Optional[Union[int, float]] Sampling frequency. Optional if attrs[\"rate\"] is specified. None Returns: Type Description DataArray A low-pass filtered xarray.DataArray Example To low-pass any xarray.DataArray (including Analogs, Angles, Markers or Rototrans) signal at 5Hz: from pyomeca import Analogs analogs = Analogs . from_random_data () analogs . meca . low_pass ( order = 2 , cutoff = 5 , freq = 100 ) Let's see how the low-pass smooth a fake sinusoidal signal: import matplotlib.pyplot as plt import numpy as np # generate fake data freq = 100 # Hz time_vector = np . linspace ( start = 0 , stop = 100 , num = 100 ) w = 2 * np . pi * 1 y = np . sin ( w * time_vector ) + 0.1 * np . sin ( 10 * w * time_vector ) analogs = Analogs ( y . reshape ( 1 , - 1 )) low_pass = analogs . meca . low_pass ( order = 2 , cutoff = 5 , freq = freq ) analogs . plot ( label = \"raw\" ) low_pass . plot ( label = \"low-pass @ 5Hz\" ) plt . legend () plt . show () Source code in pyomeca/dataarray_accessor.py def low_pass ( self , order : int , cutoff : Union [ int , float , np . array ], freq : Optional [ Union [ int , float ]] = None , ) -> xr . DataArray : \"\"\" Low-pass Butterworth filter. Arguments: order: Order of the filter cutoff: Cut-off frequency freq: Sampling frequency. Optional if attrs[\"rate\"] is specified. Returns: A low-pass filtered `xarray.DataArray` !!! example To low-pass any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans) signal at 5Hz: ```python from pyomeca import Analogs analogs = Analogs.from_random_data() analogs.meca.low_pass(order=2, cutoff=5, freq=100) ``` Let's see how the low-pass smooth a fake sinusoidal signal: ```python import matplotlib.pyplot as plt import numpy as np # generate fake data freq = 100 # Hz time_vector = np.linspace(start=0, stop=100, num=100) w = 2 * np.pi * 1 y = np.sin(w * time_vector) + 0.1 * np.sin(10 * w * time_vector) analogs = Analogs(y.reshape(1, -1)) low_pass = analogs.meca.low_pass(order=2, cutoff=5, freq=freq) analogs.plot(label=\"raw\") low_pass.plot(label=\"low-pass @ 5Hz\") plt.legend() plt.show() ``` ![low_pass](/images/api/low_pass.svg) \"\"\" return filter . low_pass ( self . _obj , order , cutoff , freq ) matmul ( self , other ) Matrix product of two arrays. Parameters: Name Type Description Default other DataArray second array to multiply required Returns: Type Description DataArray A xarray.DataArray containing the matrix product of the two arrays Example To compute the matrix product of two xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from pyomeca import Analogs first_analogs = Analogs . from_random_data () second_analogs = Analogs . from_random_data () first_analogs . meca . matmul ( second_analogs ) You can also use the shorthand @ : first_analogs @ second_analogs Source code in pyomeca/dataarray_accessor.py def matmul ( self , other : xr . DataArray ) -> xr . DataArray : \"\"\" Matrix product of two arrays. Arguments: other: second array to multiply Returns: A `xarray.DataArray` containing the matrix product of the two arrays !!! example To compute the matrix product of two `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from pyomeca import Analogs first_analogs = Analogs.from_random_data() second_analogs = Analogs.from_random_data() first_analogs.meca.matmul(second_analogs) ``` You can also use the shorthand `@`: ```python first_analogs @ second_analogs ``` \"\"\" return matrix . matmul ( self . _obj , other ) norm ( self , dim , ord = None ) Return the norm of an array. Parameters: Name Type Description Default dim Union[str, list] Name(s) of the data dimension(s) required ord int Order of the norm None Returns: Type Description DataArray A xarray.DataArray containing the norm of the matrix. Example To compute the norm of any xarray.DataArray (including Analogs, Angles, Markers or Rototrans) along a given dimension: from pyomeca import Markers markers = Markers . from_random_data () markers . meca . norm ( dim = \"axis\" ) Note If the array contains an \"axis\" dimension with a \"ones\" coordinate (e.g., the object was created using pyomeca.Markers ), this coordinate is ignored. Source code in pyomeca/dataarray_accessor.py def norm ( self , dim : Union [ str , list ], ord : int = None ) -> xr . DataArray : \"\"\" Return the norm of an array. Arguments: dim: Name(s) of the data dimension(s) ord: Order of the norm Returns: A `xarray.DataArray` containing the norm of the matrix. !!! example To compute the norm of any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans) along a given dimension: ```python from pyomeca import Markers markers = Markers.from_random_data() markers.meca.norm(dim=\"axis\") ``` Note: If the array contains an `\"axis\"` dimension with a `\"ones\"` coordinate (e.g., the object was created using `pyomeca.Markers`), this coordinate is ignored. \"\"\" return matrix . norm ( self . _obj , dim , ord ) normalize ( self , ref = None , scale = 100 ) Normalize a signal against ref on a scale of scale . Parameters: Name Type Description Default ref Union[xarray.core.dataarray.DataArray, <built-in function array>, float, int] Reference value. Could have multiple dimensions. If not provided, takes the mean along the time axis None scale Union[int, float] Scale on which to express array (e.g. if 100, the signal is normalized from 0 to 100) 100 Returns: Type Description DataArray A xarray.DataArray containing the normalized signal Example To normalize any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): import matplotlib.pyplot as plt from pyomeca import Analogs analogs = Analogs . from_random_data ( size = ( 1 , 100 )) . meca . abs () normalized = analogs . meca . normalize () normalized . plot () plt . show () By default, this function normalize against the signal's max. To specify any other value, use the ref parameter: normalized = analogs . meca . normalize ( ref = 1 ) Source code in pyomeca/dataarray_accessor.py def normalize ( self , ref : Union [ xr . DataArray , np . array , float , int ] = None , scale : Union [ int , float ] = 100 , ) -> xr . DataArray : \"\"\" Normalize a signal against `ref` on a scale of `scale`. Arguments: ref: Reference value. Could have multiple dimensions. If not provided, takes the mean along the time axis scale: Scale on which to express array (e.g. if 100, the signal is normalized from 0 to 100) Returns: A `xarray.DataArray` containing the normalized signal !!! example To normalize any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python import matplotlib.pyplot as plt from pyomeca import Analogs analogs = Analogs.from_random_data(size=(1, 100)).meca.abs() normalized = analogs.meca.normalize() normalized.plot() plt.show() ``` ![normalize](/images/api/normalize.svg) By default, this function normalize against the signal's max. To specify any other value, use the `ref` parameter: ```python normalized = analogs.meca.normalize(ref=1) ``` \"\"\" return matrix . normalize ( self . _obj , ref , scale ) rms ( self ) Return the root-mean-square of an array. Returns: Type Description DataArray A xarray.DataArray containing the root-mean-square of the matrix. Example To compute the root-mean-square of any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from pyomeca import Analogs analogs = Analogs . from_random_data () analogs . meca . rms () Source code in pyomeca/dataarray_accessor.py def rms ( self ) -> xr . DataArray : \"\"\" Return the root-mean-square of an array. Returns: A `xarray.DataArray` containing the root-mean-square of the matrix. !!! example To compute the root-mean-square of any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from pyomeca import Analogs analogs = Analogs.from_random_data() analogs.meca.rms() ``` \"\"\" return matrix . rms ( self . _obj ) sqrt ( self , ** kwargs ) Return the non-negative square-root of an array, element-wise. Parameters: Name Type Description Default kwargs For other keyword-only arguments, see the numpy docs {} Returns: Type Description DataArray A xarray.DataArray containing the square root of the matrix. Example To compute the non-negative square-root of any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from pyomeca import Analogs analogs = Analogs . from_random_data () analogs . meca . sqrt () Source code in pyomeca/dataarray_accessor.py def sqrt ( self , ** kwargs ) -> xr . DataArray : \"\"\" Return the non-negative square-root of an array, element-wise. Arguments: kwargs: For other keyword-only arguments, see the [numpy docs](https://docs.scipy.org/doc/numpy/reference/generated/numpy.sqrt.html) Returns: A `xarray.DataArray` containing the square root of the matrix. !!! example To compute the non-negative square-root of any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from pyomeca import Analogs analogs = Analogs.from_random_data() analogs.meca.sqrt() ``` \"\"\" return matrix . sqrt ( self . _obj , ** kwargs ) square ( self , ** kwargs ) Return the element-wise square of the input. Parameters: Name Type Description Default kwargs For other keyword-only arguments, see the numpy docs {} Returns: Type Description DataArray A xarray.DataArray containing the matrix squared. Example To compute the element-wise square of any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from pyomeca import Analogs analogs = Analogs . from_random_data () analogs . meca . square () Source code in pyomeca/dataarray_accessor.py def square ( self , ** kwargs ) -> xr . DataArray : \"\"\" Return the element-wise square of the input. Arguments: kwargs: For other keyword-only arguments, see the [numpy docs](https://docs.scipy.org/doc/numpy/reference/generated/numpy.square.html) Returns: A `xarray.DataArray` containing the matrix squared. !!! example To compute the element-wise square of any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from pyomeca import Analogs analogs = Analogs.from_random_data() analogs.meca.square() ``` \"\"\" return matrix . square ( self . _obj , ** kwargs ) time_normalize ( self , time_vector = None , n_frames = 100 , norm_time = False ) Time normalization used for temporal alignment of data. Parameters: Name Type Description Default time_vector Union[xarray.core.dataarray.DataArray, <built-in function array>] desired time vector (first to last time with n_frames points by default) None n_frames int if time_vector is not specified, the length of the desired time vector 100 norm_time bool Normalize the time dimension from 0 to 100 if True False Returns: Type Description DataArray A time-normalized xarray.DataArray Example To time-normalize any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): import matplotlib.pyplot as plt from pyomeca import Analogs analogs = Analogs . from_random_data ( size = ( 1 , 847 )) time_normalized = analogs . meca . time_normalize () print ( time_normalized . time . size ) # 100 To normalize the corresponding time dimension from 0 to 100%, specify norm_time=True : time_normalized = analogs . meca . time_normalize ( norm_time = True ) time_normalized . plot () plt . show () By default, time_normalize use a time vector with 100 frames from 0 to 100. However, you can specify the desired number of frames: time_normalized = analogs . meca . time_normalize ( n_frames = 500 ) print ( time_normalized . time . size ) # 500 You can also specify the desired time_vector directly in the time_vector parameter: import numpy as np time_normalized = analogs . meca . time_normalize ( time_vector = np . linspace ( 0 , 200 , 300 )) Source code in pyomeca/dataarray_accessor.py def time_normalize ( self , time_vector : Union [ xr . DataArray , np . array ] = None , n_frames : int = 100 , norm_time : bool = False , ) -> xr . DataArray : \"\"\" Time normalization used for temporal alignment of data. Arguments: time_vector: desired time vector (first to last time with n_frames points by default) n_frames: if time_vector is not specified, the length of the desired time vector norm_time: Normalize the time dimension from 0 to 100 if True Returns: A time-normalized `xarray.DataArray` !!! example To time-normalize any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python import matplotlib.pyplot as plt from pyomeca import Analogs analogs = Analogs.from_random_data(size=(1, 847)) time_normalized = analogs.meca.time_normalize() print(time_normalized.time.size) # 100 ``` To normalize the corresponding time dimension from 0 to 100%, specify `norm_time=True`: ```python time_normalized = analogs.meca.time_normalize(norm_time=True) time_normalized.plot() plt.show() ``` ![time_normalize](/images/api/time_normalize.svg) By default, `time_normalize` use a time vector with 100 frames from 0 to 100. However, you can specify the desired number of frames: ```python time_normalized = analogs.meca.time_normalize(n_frames=500) print(time_normalized.time.size) # 500 ``` You can also specify the desired time_vector directly in the `time_vector` parameter: ```python import numpy as np time_normalized = analogs.meca.time_normalize(time_vector=np.linspace(0, 200, 300)) ``` \"\"\" return interp . time_normalize ( self . _obj , time_vector , n_frames , norm_time = norm_time ) to_csv ( self , filename , wide = True ) Write a csv file from a xarray.DataArray. Parameters: Name Type Description Default filename Union[str, pathlib.Path] File path required wide Optional[bool] True if you want a wide dataframe (one column for each channel). False if you want a tidy dataframe. True Example To write a csv file from any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from pyomeca import Analogs analogs = Analogs . from_random_data () analogs . meca . to_csv ( filename = \"temp.csv\" ) By default, to_csv will export the data in a \"wide\" format (1 column by channel). You can also export the data in a \"tidy\" format with wide=False : analogs . meca . to_csv ( filename = \"temp.csv\" , wide = False ) Source code in pyomeca/dataarray_accessor.py def to_csv ( self , filename : Union [ str , Path ], wide : Optional [ bool ] = True ): \"\"\" Write a csv file from a xarray.DataArray. Arguments: filename: File path wide: True if you want a wide dataframe (one column for each channel). False if you want a tidy dataframe. !!! example To write a csv file from any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from pyomeca import Analogs analogs = Analogs.from_random_data() analogs.meca.to_csv(filename=\"temp.csv\") ``` By default, `to_csv` will export the data in a \"wide\" format (1 column by channel). You can also export the data in a \"tidy\" format with `wide=False`: ```python analogs.meca.to_csv(filename=\"temp.csv\", wide=False) ``` \"\"\" write . write_csv ( self . _obj , filename , wide ) to_matlab ( self , filename ) Write a matlab file from a xarray.DataArray. Parameters: Name Type Description Default filename Union[str, pathlib.Path] File path required Example To write a matlab file from any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from pyomeca import Analogs analogs = Analogs . from_random_data () analogs . meca . to_matlab ( filename = \"temp.mat\" ) Source code in pyomeca/dataarray_accessor.py def to_matlab ( self , filename : Union [ str , Path ]): \"\"\" Write a matlab file from a xarray.DataArray. Arguments: filename: File path !!! example To write a matlab file from any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from pyomeca import Analogs analogs = Analogs.from_random_data() analogs.meca.to_matlab(filename=\"temp.mat\") ``` \"\"\" write . write_matlab ( self . _obj , filename ) to_wide_dataframe ( self ) Return a wide pandas.DataFrame (one column by channel). Returns: Type Description DataFrame A wide pandas DataFrame (one column by channel). Works only for 2 and 3-dimensional arrays. If you want a tidy dataframe type: array.to_series() , or array.to_dataframe() . Example To return a dataframe from any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from pyomeca import Analogs analogs = Analogs . from_random_data () analogs . meca . to_wide_dataframe () Source code in pyomeca/dataarray_accessor.py def to_wide_dataframe ( self ) -> pd . DataFrame : \"\"\" Return a wide pandas.DataFrame (one column by channel). Returns: A wide pandas DataFrame (one column by channel). Works only for 2 and 3-dimensional arrays. If you want a tidy dataframe type: `array.to_series()`, or `array.to_dataframe()`. !!! example To return a dataframe from any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from pyomeca import Analogs analogs = Analogs.from_random_data() analogs.meca.to_wide_dataframe() ``` \"\"\" return write . to_wide_dataframe ( self . _obj )","title":"DataArray_accessor"},{"location":"api/dataarray_accessor/#dataarray_accessorpy","text":"","title":"dataarray_accessor.py"},{"location":"api/dataarray_accessor/#pyomeca.dataarray_accessor","text":"","title":"pyomeca.dataarray_accessor"},{"location":"api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor","text":"Meca DataArray accessor used for processing or file writing.","title":"DataArrayAccessor"},{"location":"api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.abs","text":"Calculate the absolute value element-wise. Returns: Type Description DataArray A xarray.DataArray containing the absolute of each element Example To compute the absolute value of any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from pyomeca import Analogs analogs = Analogs . from_random_data () analogs . meca . abs () Source code in pyomeca/dataarray_accessor.py def abs ( self ) -> xr . DataArray : \"\"\" Calculate the absolute value element-wise. Returns: A `xarray.DataArray` containing the absolute of each element !!! example To compute the absolute value of any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from pyomeca import Analogs analogs = Analogs.from_random_data() analogs.meca.abs() ``` \"\"\" return matrix . abs_ ( self . _obj )","title":"abs()"},{"location":"api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.band_pass","text":"Band-pass Butterworth filter. Parameters: Name Type Description Default order int Order of the filter required cutoff Union[list, tuple, <built-in function array>] Cut-off frequency such as (lower, upper) required freq Optional[Union[int, float]] Sampling frequency. Optional if attrs[\"rate\"] is specified. None Returns: Type Description DataArray A band-pass filtered xarray.DataArray Example To band-pass any xarray.DataArray (including Analogs, Angles, Markers or Rototrans) signal at 10-200Hz: import matplotlib.pyplot as plt import numpy as np from pyomeca import Analogs fake_emg = np . random . uniform ( low =- 1 , high = 1 , size = ( 1 , 1000 )) analogs = Analogs ( fake_emg ) freq = 1000 # Hz band_pass = analogs . meca . band_pass ( order = 2 , cutoff = [ 10 , 200 ], freq = freq ) analogs . plot ( label = \"raw\" ) band_pass . plot ( label = \"band-pass @ 10-200Hz\" ) plt . legend () plt . show () Source code in pyomeca/dataarray_accessor.py def band_pass ( self , order : int , cutoff : Union [ list , tuple , np . array ], freq : Optional [ Union [ int , float ]] = None , ) -> xr . DataArray : \"\"\" Band-pass Butterworth filter. Arguments: order: Order of the filter cutoff: Cut-off frequency such as (lower, upper) freq: Sampling frequency. Optional if attrs[\"rate\"] is specified. Returns: A band-pass filtered `xarray.DataArray` !!! example To band-pass any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans) signal at 10-200Hz: ```python import matplotlib.pyplot as plt import numpy as np from pyomeca import Analogs fake_emg = np.random.uniform(low=-1, high=1, size=(1, 1000)) analogs = Analogs(fake_emg) freq = 1000 # Hz band_pass = analogs.meca.band_pass(order=2, cutoff=[10, 200], freq=freq) analogs.plot(label=\"raw\") band_pass.plot(label=\"band-pass @ 10-200Hz\") plt.legend() plt.show() ``` ![band_pass](/images/api/band_pass.svg) \"\"\" return filter . band_pass ( self . _obj , order , cutoff , freq )","title":"band_pass()"},{"location":"api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.band_stop","text":"Band-stop Butterworth filter. Parameters: Name Type Description Default order int Order of the filter required cutoff Union[list, tuple, <built-in function array>] Cut-off frequency such as (lower, upper) required freq Optional[Union[int, float]] Sampling frequency. Optional if attrs[\"rate\"] is specified. None Returns: Type Description DataArray A band-stop filtered xarray.DataArray Example To band-stop any xarray.DataArray (including Analogs, Angles, Markers or Rototrans) signal at 40-60Hz: import matplotlib.pyplot as plt import numpy as np from pyomeca import Analogs fake_emg = np . random . uniform ( low =- 1 , high = 1 , size = ( 1 , 1000 )) analogs = Analogs ( fake_emg ) freq = 1000 # Hz band_stop = analogs . meca . band_stop ( order = 2 , cutoff = [ 40 , 60 ], freq = freq ) analogs . plot ( label = \"raw\" ) band_stop . plot ( label = \"band-stop @ 40-60Hz\" ) plt . legend () plt . show () Note You can also perform a notch filter with this method. A notch filter is a band-stop filter with a narrow bandwidth. It rejects a narrow frequency band and leaves the rest of the spectrum little changed. Source code in pyomeca/dataarray_accessor.py def band_stop ( self , order : int , cutoff : Union [ list , tuple , np . array ], freq : Optional [ Union [ int , float ]] = None , ) -> xr . DataArray : \"\"\" Band-stop Butterworth filter. Arguments: order: Order of the filter cutoff: Cut-off frequency such as (lower, upper) freq: Sampling frequency. Optional if attrs[\"rate\"] is specified. Returns: A band-stop filtered `xarray.DataArray` !!! example To band-stop any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans) signal at 40-60Hz: ```python import matplotlib.pyplot as plt import numpy as np from pyomeca import Analogs fake_emg = np.random.uniform(low=-1, high=1, size=(1, 1000)) analogs = Analogs(fake_emg) freq = 1000 # Hz band_stop = analogs.meca.band_stop(order=2, cutoff=[40, 60], freq=freq) analogs.plot(label=\"raw\") band_stop.plot(label=\"band-stop @ 40-60Hz\") plt.legend() plt.show() ``` ![band_stop](/images/api/band_stop.svg) !!! note You can also perform a notch filter with this method. A notch filter is a band-stop filter with a narrow bandwidth. It rejects a narrow frequency band and leaves the rest of the spectrum little changed. \"\"\" return filter . band_stop ( self . _obj , order , cutoff , freq )","title":"band_stop()"},{"location":"api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.center","text":"Center an array (i.e., subtract the mean). Parameters: Name Type Description Default mu Union[xarray.core.dataarray.DataArray, <built-in function array>, float, int] the value to be subtracted. If unspecified, take the mean along the time axis. None Returns: Type Description DataArray a xarray.DataArray containing the root-mean-square of the matrix Example To center any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): import numpy as np from pyomeca import Analogs random_data = np . random . uniform ( low = 2 , high = 4 , size = ( 1 , 100 )) analogs = Analogs ( random_data ) centered = analogs . meca . center () This will substract the mean of the signal by default. The previous random signal was sampled from a uniform distribution from 2 and 4 (mean around 3). When centered, the signal is now center around 0 (mean around 0). import matplotlib.pyplot as plt analogs . plot ( label = \"raw\" ) centered . plot ( label = \"centered\" ) plt . legend () plt . show () Source code in pyomeca/dataarray_accessor.py def center ( self , mu : Union [ xr . DataArray , np . array , float , int ] = None ) -> xr . DataArray : \"\"\" Center an array (i.e., subtract the mean). Arguments: mu: the value to be subtracted. If unspecified, take the mean along the time axis. Returns: a `xarray.DataArray` containing the root-mean-square of the matrix !!! example To center any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python import numpy as np from pyomeca import Analogs random_data = np.random.uniform(low=2, high=4, size=(1, 100)) analogs = Analogs(random_data) centered = analogs.meca.center() ``` This will substract the mean of the signal by default. The previous random signal was sampled from a uniform distribution from 2 and 4 (mean around 3). When centered, the signal is now center around 0 (mean around 0). ```python import matplotlib.pyplot as plt analogs.plot(label=\"raw\") centered.plot(label=\"centered\") plt.legend() plt.show() ``` ![center](/images/api/center.svg) \"\"\" return matrix . center ( self . _obj , mu )","title":"center()"},{"location":"api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.detect_onset","text":"Detects onset based on amplitude threshold. Parameters: Name Type Description Default threshold Union[float, int] minimum amplitude to detect required n_above int minimum number of continuous samples >= threshold to detect 1 n_below int minimum number of continuous samples below threshold that will be ignored in the detection of x >= threshold 0 threshold2 int minimum amplitude of n_above2 values in x to detect None n_above2 int minimum number of samples >= threshold2 to detect 1 Note You might have to tune the parameters according to the signal-to-noise characteristic of the data. Returns: Type Description <built-in function array> inds: 1D array_like [indi, indf] containing initial and final indexes of the onset events Example To detect the onsets of any one-dimensional xarray.DataArray (including Analogs, Angles, Markers or Rototrans): import matplotlib.pyplot as plt import numpy as np import scipy.signal as sig from pyomeca import Analogs # simulate fake ecg data rr = 2.5 # rr time in seconds freq = 100 # sampling rate pqrst = sig . resample ( sig . wavelets . daub ( 10 ), int ( rr * freq )) ecg = np . concatenate ([ pqrst , pqrst , pqrst ]) . reshape ( 1 , - 1 ) analogs = Analogs ( ecg ) analogs . plot () onsets = analogs . sel ( channel = 0 ) . meca . detect_onset ( threshold = analogs . mean (), # mean of the signal n_above = freq / 2 , # we want at least 1/2 second above the threshold n_below = freq / 2 , # we accept point below threshold for 1/2 second ) for ( start , end ) in onsets : plt . axvline ( x = start , color = \"g\" ) plt . axvline ( x = end , color = \"r\" ) plt . show () Warning detect_onset works only for 1-dimensional data. For example, you can select a dimension using analogs.sel(channel='EMG1') or analogs.isel(channel=0) . Source code in pyomeca/dataarray_accessor.py def detect_onset ( self , threshold : Union [ float , int ], n_above : int = 1 , n_below : int = 0 , threshold2 : int = None , n_above2 : int = 1 , ) -> np . array : \"\"\" Detects onset based on amplitude threshold. Arguments: threshold: minimum amplitude to detect n_above: minimum number of continuous samples >= `threshold` to detect n_below: minimum number of continuous samples below `threshold` that will be ignored in the detection of `x` >= `threshold` threshold2: minimum amplitude of `n_above2` values in `x` to detect n_above2: minimum number of samples >= `threshold2` to detect Note: You might have to tune the parameters according to the signal-to-noise characteristic of the data. Returns: inds: 1D array_like [indi, indf] containing initial and final indexes of the onset events !!! example To detect the onsets of any __one-dimensional__ `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python import matplotlib.pyplot as plt import numpy as np import scipy.signal as sig from pyomeca import Analogs # simulate fake ecg data rr = 2.5 # rr time in seconds freq = 100 # sampling rate pqrst = sig.resample(sig.wavelets.daub(10), int(rr * freq)) ecg = np.concatenate([pqrst, pqrst, pqrst]).reshape(1, -1) analogs = Analogs(ecg) analogs.plot() onsets = analogs.sel(channel=0).meca.detect_onset( threshold=analogs.mean(), # mean of the signal n_above=freq / 2, # we want at least 1/2 second above the threshold n_below=freq / 2, # we accept point below threshold for 1/2 second ) for (start, end) in onsets: plt.axvline(x=start, color=\"g\") plt.axvline(x=end, color=\"r\") plt.show() ``` ![detect_onset](/images/api/detect_onset.svg) !!! warning `detect_onset` works only for 1-dimensional data. For example, you can select a dimension using `analogs.sel(channel='EMG1')` or `analogs.isel(channel=0)`. \"\"\" return misc . detect_onset ( self . _obj , threshold , n_above , n_below , threshold2 , n_above2 )","title":"detect_onset()"},{"location":"api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.detect_outliers","text":"Detects data points that are threshold times the standard deviation from the mean. Parameters: Name Type Description Default threshold int Multiple of standard deviation from which data is considered outlier 3 Returns: Type Description DataArray A boolean xarray.DataArray containing the outliers Example To get a boolean xr.DataArray containing the data that are 3 times the mean +/- standard deviation: from pyomeca import Analogs analogs = Analogs . from_random_data () outliers = analogs . meca . detect_outliers ( threshold = 1 ) Let's plot the data that are 1 time the mean +/- standard deviation on an analog vector: import matplotlib.pyplot as plt analogs = Analogs . from_random_data ( size = ( 1 , 100 )) threshold = 1 outliers = analogs . meca . detect_outliers ( threshold = threshold ) analogs . plot . line ( x = \"time\" , color = \"black\" , add_legend = False ) analogs . where ( outliers ) . plot . line ( x = \"time\" , color = \"red\" , add_legend = False , marker = \"o\" , label = \"outliers\" ) mu = analogs . mean () sigma = analogs . std () plt . axhline ( mu , color = \"grey\" ) plt . axhspan ( mu - threshold * sigma , mu + threshold * sigma , color = \"grey\" , alpha = 0.3 , label = f \"mean +/- { threshold } std\" , ) plt . legend () plt . show () Note detect_outliers is not limited on one-dimensional data and can detect outliers for any number of dimensions. Source code in pyomeca/dataarray_accessor.py def detect_outliers ( self , threshold : int = 3 ) -> xr . DataArray : \"\"\" Detects data points that are `threshold` times the standard deviation from the mean. Arguments: threshold: Multiple of standard deviation from which data is considered outlier Returns: A boolean `xarray.DataArray` containing the outliers !!! example To get a boolean `xr.DataArray` containing the data that are 3 times the mean +/- standard deviation: ```python from pyomeca import Analogs analogs = Analogs.from_random_data() outliers = analogs.meca.detect_outliers(threshold=1) ``` Let's plot the data that are 1 time the mean +/- standard deviation on an analog vector: ```python import matplotlib.pyplot as plt analogs = Analogs.from_random_data(size=(1, 100)) threshold = 1 outliers = analogs.meca.detect_outliers(threshold=threshold) analogs.plot.line(x=\"time\", color=\"black\", add_legend=False) analogs.where(outliers).plot.line( x=\"time\", color=\"red\", add_legend=False, marker=\"o\", label=\"outliers\" ) mu = analogs.mean() sigma = analogs.std() plt.axhline(mu, color=\"grey\") plt.axhspan( mu - threshold * sigma, mu + threshold * sigma, color=\"grey\", alpha=0.3, label=f\"mean +/- {threshold} std\", ) plt.legend() plt.show() ``` ![detect_outliers](/images/api/detect_outliers.svg) Note: `detect_outliers` is not limited on one-dimensional data and can detect outliers for any number of dimensions. \"\"\" return misc . detect_outliers ( self . _obj , threshold )","title":"detect_outliers()"},{"location":"api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.fft","text":"Performs a discrete Fourier Transform and return a DataArray with the corresponding amplitudes and frequencies. Parameters: Name Type Description Default freq Union[int, float] Sampling frequency (usually stored in array.attrs[\"rate\"] ) required only_positive bool If True , returns only the positive frequencies True Returns: Type Description DataArray A xarray.DataArray with the corresponding amplitudes and frequencies Example Let's compare the resulting fft on a raw and low-passed signal: import matplotlib.pyplot as plt import numpy as np from pyomeca import Analogs # generate fake data freq = 100 time = np . arange ( 0 , 1 , 0.01 ) w = 2 * np . pi y = np . sin ( w * time ) + 0.1 * np . sin ( 10 * w * time ) analogs = Analogs ( y . reshape ( 1 , - 1 )) analogs_low_passed = analogs . meca . low_pass ( order = 2 , cutoff = 5 , freq = freq ) # compute fft on raw and low-passed signal fft_raw = analogs . meca . fft ( freq = freq ) fft_low_passed = analogs_low_passed . meca . fft ( freq = freq ) fig , ax = plt . subplots ( ncols = 2 , figsize = ( 10 , 4 )) # plot signal vs. time analogs . plot . line ( x = \"time\" , ax = ax [ 0 ], color = \"black\" , add_legend = False ) analogs_low_passed . plot . line ( x = \"time\" , ax = ax [ 0 ], color = \"red\" , add_legend = False ) ax [ 0 ] . set_title ( \"Signal vs. Time\" ) # plot amplitudes vs. frequencies fft_raw . plot . line ( x = \"freq\" , ax = ax [ 1 ], color = \"black\" , label = \"raw\" ) fft_low_passed . plot . line ( x = \"freq\" , ax = ax [ 1 ], color = \"red\" , label = \"low-pass @ 5Hz\" ) ax [ 1 ] . set_title ( \"Amplitudes vs. Freq\" ) plt . legend () plt . show () Source code in pyomeca/dataarray_accessor.py def fft ( self , freq : Union [ int , float ], only_positive : bool = True ) -> xr . DataArray : \"\"\" Performs a discrete Fourier Transform and return a DataArray with the corresponding amplitudes and frequencies. Arguments: freq: Sampling frequency (usually stored in `array.attrs[\"rate\"]`) only_positive: If `True`, returns only the positive frequencies Returns: A `xarray.DataArray` with the corresponding amplitudes and frequencies !!! example Let's compare the resulting fft on a raw and low-passed signal: ```python import matplotlib.pyplot as plt import numpy as np from pyomeca import Analogs # generate fake data freq = 100 time = np.arange(0, 1, 0.01) w = 2 * np.pi y = np.sin(w * time) + 0.1 * np.sin(10 * w * time) analogs = Analogs(y.reshape(1, -1)) analogs_low_passed = analogs.meca.low_pass(order=2, cutoff=5, freq=freq) # compute fft on raw and low-passed signal fft_raw = analogs.meca.fft(freq=freq) fft_low_passed = analogs_low_passed.meca.fft(freq=freq) fig, ax = plt.subplots(ncols=2, figsize=(10, 4)) # plot signal vs. time analogs.plot.line(x=\"time\", ax=ax[0], color=\"black\", add_legend=False) analogs_low_passed.plot.line(x=\"time\", ax=ax[0], color=\"red\", add_legend=False) ax[0].set_title(\"Signal vs. Time\") # plot amplitudes vs. frequencies fft_raw.plot.line(x=\"freq\", ax=ax[1], color=\"black\", label=\"raw\") fft_low_passed.plot.line(x=\"freq\", ax=ax[1], color=\"red\", label=\"low-pass @ 5Hz\") ax[1].set_title(\"Amplitudes vs. Freq\") plt.legend() plt.show() ``` ![fft](/images/api/fft.svg) \"\"\" return misc . fft ( self . _obj , freq , only_positive )","title":"fft()"},{"location":"api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.high_pass","text":"High-pass Butterworth filter. Parameters: Name Type Description Default order int Order of the filter required cutoff Union[int, float, <built-in function array>] Cut-off frequency required freq Optional[Union[int, float]] Sampling frequency. Optional if attrs[\"rate\"] is specified. None Returns: Type Description DataArray A high-pass filtered xarray.DataArray Example To high-pass any xarray.DataArray (including Analogs, Angles, Markers or Rototrans) signal at 100Hz: import matplotlib.pyplot as plt import numpy as np from pyomeca import Analogs fake_emg = np . random . uniform ( low =- 1 , high = 1 , size = ( 1 , 1000 )) analogs = Analogs ( fake_emg ) freq = 1000 # Hz high_pass = analogs . meca . high_pass ( order = 2 , cutoff = 100 , freq = freq ) analogs . plot ( label = \"raw\" ) high_pass . plot ( label = \"high-pass @ 100Hz\" ) plt . legend () plt . show () Source code in pyomeca/dataarray_accessor.py def high_pass ( self , order : int , cutoff : Union [ int , float , np . array ], freq : Optional [ Union [ int , float ]] = None , ) -> xr . DataArray : \"\"\" High-pass Butterworth filter. Arguments: order: Order of the filter cutoff: Cut-off frequency freq: Sampling frequency. Optional if attrs[\"rate\"] is specified. Returns: A high-pass filtered `xarray.DataArray` !!! example To high-pass any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans) signal at 100Hz: ```python import matplotlib.pyplot as plt import numpy as np from pyomeca import Analogs fake_emg = np.random.uniform(low=-1, high=1, size=(1, 1000)) analogs = Analogs(fake_emg) freq = 1000 # Hz high_pass = analogs.meca.high_pass(order=2, cutoff=100, freq=freq) analogs.plot(label=\"raw\") high_pass.plot(label=\"high-pass @ 100Hz\") plt.legend() plt.show() ``` ![high_pass](/images/api/high_pass.svg) \"\"\" return filter . high_pass ( self . _obj , order , cutoff , freq )","title":"high_pass()"},{"location":"api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.low_pass","text":"Low-pass Butterworth filter. Parameters: Name Type Description Default order int Order of the filter required cutoff Union[int, float, <built-in function array>] Cut-off frequency required freq Optional[Union[int, float]] Sampling frequency. Optional if attrs[\"rate\"] is specified. None Returns: Type Description DataArray A low-pass filtered xarray.DataArray Example To low-pass any xarray.DataArray (including Analogs, Angles, Markers or Rototrans) signal at 5Hz: from pyomeca import Analogs analogs = Analogs . from_random_data () analogs . meca . low_pass ( order = 2 , cutoff = 5 , freq = 100 ) Let's see how the low-pass smooth a fake sinusoidal signal: import matplotlib.pyplot as plt import numpy as np # generate fake data freq = 100 # Hz time_vector = np . linspace ( start = 0 , stop = 100 , num = 100 ) w = 2 * np . pi * 1 y = np . sin ( w * time_vector ) + 0.1 * np . sin ( 10 * w * time_vector ) analogs = Analogs ( y . reshape ( 1 , - 1 )) low_pass = analogs . meca . low_pass ( order = 2 , cutoff = 5 , freq = freq ) analogs . plot ( label = \"raw\" ) low_pass . plot ( label = \"low-pass @ 5Hz\" ) plt . legend () plt . show () Source code in pyomeca/dataarray_accessor.py def low_pass ( self , order : int , cutoff : Union [ int , float , np . array ], freq : Optional [ Union [ int , float ]] = None , ) -> xr . DataArray : \"\"\" Low-pass Butterworth filter. Arguments: order: Order of the filter cutoff: Cut-off frequency freq: Sampling frequency. Optional if attrs[\"rate\"] is specified. Returns: A low-pass filtered `xarray.DataArray` !!! example To low-pass any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans) signal at 5Hz: ```python from pyomeca import Analogs analogs = Analogs.from_random_data() analogs.meca.low_pass(order=2, cutoff=5, freq=100) ``` Let's see how the low-pass smooth a fake sinusoidal signal: ```python import matplotlib.pyplot as plt import numpy as np # generate fake data freq = 100 # Hz time_vector = np.linspace(start=0, stop=100, num=100) w = 2 * np.pi * 1 y = np.sin(w * time_vector) + 0.1 * np.sin(10 * w * time_vector) analogs = Analogs(y.reshape(1, -1)) low_pass = analogs.meca.low_pass(order=2, cutoff=5, freq=freq) analogs.plot(label=\"raw\") low_pass.plot(label=\"low-pass @ 5Hz\") plt.legend() plt.show() ``` ![low_pass](/images/api/low_pass.svg) \"\"\" return filter . low_pass ( self . _obj , order , cutoff , freq )","title":"low_pass()"},{"location":"api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.matmul","text":"Matrix product of two arrays. Parameters: Name Type Description Default other DataArray second array to multiply required Returns: Type Description DataArray A xarray.DataArray containing the matrix product of the two arrays Example To compute the matrix product of two xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from pyomeca import Analogs first_analogs = Analogs . from_random_data () second_analogs = Analogs . from_random_data () first_analogs . meca . matmul ( second_analogs ) You can also use the shorthand @ : first_analogs @ second_analogs Source code in pyomeca/dataarray_accessor.py def matmul ( self , other : xr . DataArray ) -> xr . DataArray : \"\"\" Matrix product of two arrays. Arguments: other: second array to multiply Returns: A `xarray.DataArray` containing the matrix product of the two arrays !!! example To compute the matrix product of two `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from pyomeca import Analogs first_analogs = Analogs.from_random_data() second_analogs = Analogs.from_random_data() first_analogs.meca.matmul(second_analogs) ``` You can also use the shorthand `@`: ```python first_analogs @ second_analogs ``` \"\"\" return matrix . matmul ( self . _obj , other )","title":"matmul()"},{"location":"api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.norm","text":"Return the norm of an array. Parameters: Name Type Description Default dim Union[str, list] Name(s) of the data dimension(s) required ord int Order of the norm None Returns: Type Description DataArray A xarray.DataArray containing the norm of the matrix. Example To compute the norm of any xarray.DataArray (including Analogs, Angles, Markers or Rototrans) along a given dimension: from pyomeca import Markers markers = Markers . from_random_data () markers . meca . norm ( dim = \"axis\" ) Note If the array contains an \"axis\" dimension with a \"ones\" coordinate (e.g., the object was created using pyomeca.Markers ), this coordinate is ignored. Source code in pyomeca/dataarray_accessor.py def norm ( self , dim : Union [ str , list ], ord : int = None ) -> xr . DataArray : \"\"\" Return the norm of an array. Arguments: dim: Name(s) of the data dimension(s) ord: Order of the norm Returns: A `xarray.DataArray` containing the norm of the matrix. !!! example To compute the norm of any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans) along a given dimension: ```python from pyomeca import Markers markers = Markers.from_random_data() markers.meca.norm(dim=\"axis\") ``` Note: If the array contains an `\"axis\"` dimension with a `\"ones\"` coordinate (e.g., the object was created using `pyomeca.Markers`), this coordinate is ignored. \"\"\" return matrix . norm ( self . _obj , dim , ord )","title":"norm()"},{"location":"api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.normalize","text":"Normalize a signal against ref on a scale of scale . Parameters: Name Type Description Default ref Union[xarray.core.dataarray.DataArray, <built-in function array>, float, int] Reference value. Could have multiple dimensions. If not provided, takes the mean along the time axis None scale Union[int, float] Scale on which to express array (e.g. if 100, the signal is normalized from 0 to 100) 100 Returns: Type Description DataArray A xarray.DataArray containing the normalized signal Example To normalize any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): import matplotlib.pyplot as plt from pyomeca import Analogs analogs = Analogs . from_random_data ( size = ( 1 , 100 )) . meca . abs () normalized = analogs . meca . normalize () normalized . plot () plt . show () By default, this function normalize against the signal's max. To specify any other value, use the ref parameter: normalized = analogs . meca . normalize ( ref = 1 ) Source code in pyomeca/dataarray_accessor.py def normalize ( self , ref : Union [ xr . DataArray , np . array , float , int ] = None , scale : Union [ int , float ] = 100 , ) -> xr . DataArray : \"\"\" Normalize a signal against `ref` on a scale of `scale`. Arguments: ref: Reference value. Could have multiple dimensions. If not provided, takes the mean along the time axis scale: Scale on which to express array (e.g. if 100, the signal is normalized from 0 to 100) Returns: A `xarray.DataArray` containing the normalized signal !!! example To normalize any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python import matplotlib.pyplot as plt from pyomeca import Analogs analogs = Analogs.from_random_data(size=(1, 100)).meca.abs() normalized = analogs.meca.normalize() normalized.plot() plt.show() ``` ![normalize](/images/api/normalize.svg) By default, this function normalize against the signal's max. To specify any other value, use the `ref` parameter: ```python normalized = analogs.meca.normalize(ref=1) ``` \"\"\" return matrix . normalize ( self . _obj , ref , scale )","title":"normalize()"},{"location":"api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.rms","text":"Return the root-mean-square of an array. Returns: Type Description DataArray A xarray.DataArray containing the root-mean-square of the matrix. Example To compute the root-mean-square of any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from pyomeca import Analogs analogs = Analogs . from_random_data () analogs . meca . rms () Source code in pyomeca/dataarray_accessor.py def rms ( self ) -> xr . DataArray : \"\"\" Return the root-mean-square of an array. Returns: A `xarray.DataArray` containing the root-mean-square of the matrix. !!! example To compute the root-mean-square of any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from pyomeca import Analogs analogs = Analogs.from_random_data() analogs.meca.rms() ``` \"\"\" return matrix . rms ( self . _obj )","title":"rms()"},{"location":"api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.sqrt","text":"Return the non-negative square-root of an array, element-wise. Parameters: Name Type Description Default kwargs For other keyword-only arguments, see the numpy docs {} Returns: Type Description DataArray A xarray.DataArray containing the square root of the matrix. Example To compute the non-negative square-root of any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from pyomeca import Analogs analogs = Analogs . from_random_data () analogs . meca . sqrt () Source code in pyomeca/dataarray_accessor.py def sqrt ( self , ** kwargs ) -> xr . DataArray : \"\"\" Return the non-negative square-root of an array, element-wise. Arguments: kwargs: For other keyword-only arguments, see the [numpy docs](https://docs.scipy.org/doc/numpy/reference/generated/numpy.sqrt.html) Returns: A `xarray.DataArray` containing the square root of the matrix. !!! example To compute the non-negative square-root of any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from pyomeca import Analogs analogs = Analogs.from_random_data() analogs.meca.sqrt() ``` \"\"\" return matrix . sqrt ( self . _obj , ** kwargs )","title":"sqrt()"},{"location":"api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.square","text":"Return the element-wise square of the input. Parameters: Name Type Description Default kwargs For other keyword-only arguments, see the numpy docs {} Returns: Type Description DataArray A xarray.DataArray containing the matrix squared. Example To compute the element-wise square of any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from pyomeca import Analogs analogs = Analogs . from_random_data () analogs . meca . square () Source code in pyomeca/dataarray_accessor.py def square ( self , ** kwargs ) -> xr . DataArray : \"\"\" Return the element-wise square of the input. Arguments: kwargs: For other keyword-only arguments, see the [numpy docs](https://docs.scipy.org/doc/numpy/reference/generated/numpy.square.html) Returns: A `xarray.DataArray` containing the matrix squared. !!! example To compute the element-wise square of any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from pyomeca import Analogs analogs = Analogs.from_random_data() analogs.meca.square() ``` \"\"\" return matrix . square ( self . _obj , ** kwargs )","title":"square()"},{"location":"api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.time_normalize","text":"Time normalization used for temporal alignment of data. Parameters: Name Type Description Default time_vector Union[xarray.core.dataarray.DataArray, <built-in function array>] desired time vector (first to last time with n_frames points by default) None n_frames int if time_vector is not specified, the length of the desired time vector 100 norm_time bool Normalize the time dimension from 0 to 100 if True False Returns: Type Description DataArray A time-normalized xarray.DataArray Example To time-normalize any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): import matplotlib.pyplot as plt from pyomeca import Analogs analogs = Analogs . from_random_data ( size = ( 1 , 847 )) time_normalized = analogs . meca . time_normalize () print ( time_normalized . time . size ) # 100 To normalize the corresponding time dimension from 0 to 100%, specify norm_time=True : time_normalized = analogs . meca . time_normalize ( norm_time = True ) time_normalized . plot () plt . show () By default, time_normalize use a time vector with 100 frames from 0 to 100. However, you can specify the desired number of frames: time_normalized = analogs . meca . time_normalize ( n_frames = 500 ) print ( time_normalized . time . size ) # 500 You can also specify the desired time_vector directly in the time_vector parameter: import numpy as np time_normalized = analogs . meca . time_normalize ( time_vector = np . linspace ( 0 , 200 , 300 )) Source code in pyomeca/dataarray_accessor.py def time_normalize ( self , time_vector : Union [ xr . DataArray , np . array ] = None , n_frames : int = 100 , norm_time : bool = False , ) -> xr . DataArray : \"\"\" Time normalization used for temporal alignment of data. Arguments: time_vector: desired time vector (first to last time with n_frames points by default) n_frames: if time_vector is not specified, the length of the desired time vector norm_time: Normalize the time dimension from 0 to 100 if True Returns: A time-normalized `xarray.DataArray` !!! example To time-normalize any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python import matplotlib.pyplot as plt from pyomeca import Analogs analogs = Analogs.from_random_data(size=(1, 847)) time_normalized = analogs.meca.time_normalize() print(time_normalized.time.size) # 100 ``` To normalize the corresponding time dimension from 0 to 100%, specify `norm_time=True`: ```python time_normalized = analogs.meca.time_normalize(norm_time=True) time_normalized.plot() plt.show() ``` ![time_normalize](/images/api/time_normalize.svg) By default, `time_normalize` use a time vector with 100 frames from 0 to 100. However, you can specify the desired number of frames: ```python time_normalized = analogs.meca.time_normalize(n_frames=500) print(time_normalized.time.size) # 500 ``` You can also specify the desired time_vector directly in the `time_vector` parameter: ```python import numpy as np time_normalized = analogs.meca.time_normalize(time_vector=np.linspace(0, 200, 300)) ``` \"\"\" return interp . time_normalize ( self . _obj , time_vector , n_frames , norm_time = norm_time )","title":"time_normalize()"},{"location":"api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.to_csv","text":"Write a csv file from a xarray.DataArray. Parameters: Name Type Description Default filename Union[str, pathlib.Path] File path required wide Optional[bool] True if you want a wide dataframe (one column for each channel). False if you want a tidy dataframe. True Example To write a csv file from any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from pyomeca import Analogs analogs = Analogs . from_random_data () analogs . meca . to_csv ( filename = \"temp.csv\" ) By default, to_csv will export the data in a \"wide\" format (1 column by channel). You can also export the data in a \"tidy\" format with wide=False : analogs . meca . to_csv ( filename = \"temp.csv\" , wide = False ) Source code in pyomeca/dataarray_accessor.py def to_csv ( self , filename : Union [ str , Path ], wide : Optional [ bool ] = True ): \"\"\" Write a csv file from a xarray.DataArray. Arguments: filename: File path wide: True if you want a wide dataframe (one column for each channel). False if you want a tidy dataframe. !!! example To write a csv file from any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from pyomeca import Analogs analogs = Analogs.from_random_data() analogs.meca.to_csv(filename=\"temp.csv\") ``` By default, `to_csv` will export the data in a \"wide\" format (1 column by channel). You can also export the data in a \"tidy\" format with `wide=False`: ```python analogs.meca.to_csv(filename=\"temp.csv\", wide=False) ``` \"\"\" write . write_csv ( self . _obj , filename , wide )","title":"to_csv()"},{"location":"api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.to_matlab","text":"Write a matlab file from a xarray.DataArray. Parameters: Name Type Description Default filename Union[str, pathlib.Path] File path required Example To write a matlab file from any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from pyomeca import Analogs analogs = Analogs . from_random_data () analogs . meca . to_matlab ( filename = \"temp.mat\" ) Source code in pyomeca/dataarray_accessor.py def to_matlab ( self , filename : Union [ str , Path ]): \"\"\" Write a matlab file from a xarray.DataArray. Arguments: filename: File path !!! example To write a matlab file from any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from pyomeca import Analogs analogs = Analogs.from_random_data() analogs.meca.to_matlab(filename=\"temp.mat\") ``` \"\"\" write . write_matlab ( self . _obj , filename )","title":"to_matlab()"},{"location":"api/dataarray_accessor/#pyomeca.dataarray_accessor.DataArrayAccessor.to_wide_dataframe","text":"Return a wide pandas.DataFrame (one column by channel). Returns: Type Description DataFrame A wide pandas DataFrame (one column by channel). Works only for 2 and 3-dimensional arrays. If you want a tidy dataframe type: array.to_series() , or array.to_dataframe() . Example To return a dataframe from any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from pyomeca import Analogs analogs = Analogs . from_random_data () analogs . meca . to_wide_dataframe () Source code in pyomeca/dataarray_accessor.py def to_wide_dataframe ( self ) -> pd . DataFrame : \"\"\" Return a wide pandas.DataFrame (one column by channel). Returns: A wide pandas DataFrame (one column by channel). Works only for 2 and 3-dimensional arrays. If you want a tidy dataframe type: `array.to_series()`, or `array.to_dataframe()`. !!! example To return a dataframe from any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from pyomeca import Analogs analogs = Analogs.from_random_data() analogs.meca.to_wide_dataframe() ``` \"\"\" return write . to_wide_dataframe ( self . _obj )","title":"to_wide_dataframe()"},{"location":"api/markers/","text":"markers.py Markers __new__ ( cls , data = None , channels = None , time = None , ** kwargs ) special staticmethod Markers DataArray with axis , channel and time dimensions used for skin marker positions. Parameters: Name Type Description Default data Optional[Union[<built-in function array>, numpy.ndarray, xarray.core.dataarray.DataArray]] Array to be passed to xarray.DataArray None channels Optional[list] Channel names None time Optional[Union[<built-in function array>, list, pandas.core.series.Series]] Time vector in seconds associated with the data parameter None kwargs Keyword argument(s) to be passed to xarray.DataArray {} Returns: Type Description DataArray Markers xarray.DataArray with the specified data and coordinates Example To instantiate a Markers with 4 channels and 100 frames filled with some random data: import numpy as np from pyomeca import Markers n_axis = 3 n_channels = 4 n_frames = 100 data = np . random . random ( size = ( n_axis , n_channels , n_frames )) markers = Markers ( data ) You can add the channel names: names = [ \"A\" , \"B\" , \"C\" , \"D\" ] markers = Markers ( data , channels = names ) And an associate time vector: rate = 100 # Hz time = np . arange ( start = 0 , stop = n_frames / rate , step = 1 / rate ) markers = Markers ( data , channels = names , time = time ) Note Calling Markers() generate an empty array. Source code in pyomeca/markers.py def __new__ ( cls , data : Optional [ Union [ np . array , np . ndarray , xr . DataArray ]] = None , channels : Optional [ list ] = None , time : Optional [ Union [ np . array , list , pd . Series ]] = None , ** kwargs , ) -> xr . DataArray : \"\"\" Markers DataArray with `axis`, `channel` and `time` dimensions used for skin marker positions. ![markers](/images/objects/markers.svg) Arguments: data: Array to be passed to xarray.DataArray channels: Channel names time: Time vector in seconds associated with the `data` parameter kwargs: Keyword argument(s) to be passed to xarray.DataArray Returns: Markers `xarray.DataArray` with the specified data and coordinates !!! example To instantiate a `Markers` with 4 channels and 100 frames filled with some random data: ```python import numpy as np from pyomeca import Markers n_axis = 3 n_channels = 4 n_frames = 100 data = np.random.random(size=(n_axis, n_channels, n_frames)) markers = Markers(data) ``` You can add the channel names: ```python names = [\"A\", \"B\", \"C\", \"D\"] markers = Markers(data, channels=names) ``` And an associate time vector: ```python rate = 100 # Hz time = np.arange(start=0, stop=n_frames / rate, step=1 / rate) markers = Markers(data, channels=names, time=time) ``` !!! note Calling `Markers()` generate an empty array. \"\"\" coords = {} if data is None : data = np . ndarray (( 0 , 0 , 0 )) else : coords [ \"axis\" ] = [ \"x\" , \"y\" , \"z\" , \"ones\" ] if data . shape [ 0 ] == 3 : data = np . insert ( data , obj = 3 , values = 1 , axis = 0 ) if channels : coords [ \"channel\" ] = channels if time is not None : coords [ \"time\" ] = time return xr . DataArray ( data = data , dims = ( \"axis\" , \"channel\" , \"time\" ), coords = coords , name = \"markers\" , ** kwargs , ) from_c3d ( filename , usecols = None , prefix_delimiter = None , suffix_delimiter = None , attrs = None ) classmethod Markers DataArray from a c3d file. Parameters: Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None attrs Optional[dict] attrs to be passed to xr.DataArray None Returns: Type Description DataArray Markers xarray.DataArray with the specified data and coordinates Example To read this c3d file , type: from pyomeca import Markers data_path = \"./tests/data/markers_analogs.c3d\" markers = Markers . from_c3d ( data_path ) If you know the channel names, you can retrieve only the ones you are interested in: channels = [ \"Daphnee:ASISl\" , \"Daphnee:PSISr\" , \"Daphnee:PSISl\" ] markers = Markers . from_c3d ( data_path , usecols = channels ) Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify prefix_delimiter and suffix_delimiter for the suffix. For example, if the name is \"\"Daphnee:ASISl\" and you specify suffix_delimiter=\":\" , you will select \"Daphnee\". Similarly, if you specify `prefix_delimiter=\":\": channels = [ \"ASISl\" , \"PSISr\" , \"PSISl\" ] markers = Markers . from_c3d ( data_path , prefix_delimiter = \":\" ) Source code in pyomeca/markers.py @classmethod def from_c3d ( cls , filename : Union [ str , Path ], usecols : Optional [ List [ Union [ str , int ]]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Markers DataArray from a c3d file. Arguments: filename: Any valid string path usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) attrs: attrs to be passed to xr.DataArray Returns: Markers `xarray.DataArray` with the specified data and coordinates !!! example To read [this c3d file](https://github.com/pyomeca/pyomeca/blob/master/tests/data/markers_analogs.c3d), type: ```python from pyomeca import Markers data_path = \"./tests/data/markers_analogs.c3d\" markers = Markers.from_c3d(data_path) ``` If you know the channel names, you can retrieve only the ones you are interested in: ```python channels = [\"Daphnee:ASISl\", \"Daphnee:PSISr\", \"Daphnee:PSISl\"] markers = Markers.from_c3d(data_path, usecols=channels) ``` Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify `prefix_delimiter` and `suffix_delimiter` for the suffix. For example, if the name is `\"\"Daphnee:ASISl\"` and you specify `suffix_delimiter=\":\"`, you will select \"Daphnee\". Similarly, if you specify `prefix_delimiter=\":\": ```python channels = [\"ASISl\", \"PSISr\", \"PSISl\"] markers = Markers.from_c3d(data_path, prefix_delimiter=\":\") ``` \"\"\" return read . read_c3d ( cls , filename , usecols , prefix_delimiter , suffix_delimiter , attrs ) from_csv ( filename , usecols = None , header = None , first_row = 0 , first_column = None , time_column = None , trailing_columns = None , prefix_delimiter = None , suffix_delimiter = None , skip_rows = None , pandas_kwargs = None , attrs = None ) classmethod Markers DataArray from a csv file. Parameters: Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. None header Optional[int] Row of the header (0-indexed) None first_row int First row of the data (0-indexed) 0 first_column Optional[Union[str, int]] First column of the data (0-indexed) None time_column Optional[Union[str, int]] Location of the time column. If None, indices are associated None trailing_columns Optional[Union[str, int]] If for some reason the csv reads extra columns, how many should be ignored None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None skip_rows Optional[List[int]] Line numbers to skip (0-indexed) None pandas_kwargs Optional[dict] Keyword arguments to be passed to pandas.read_csv None attrs Optional[dict] attrs to be passed to xr.DataArray . If attrs['rate'] is provided, compute the time accordingly None Returns: Type Description DataArray Markers xarray.DataArray with the specified data and coordinates Example To read this csv file , type: from pyomeca import Markers data_path = \"./tests/data/markers.csv\" markers = Markers . from_csv ( data_path , header = 2 , first_row = 5 , first_column = 2 ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"Daphnee:ASISr\" , \"Daphnee:ASISl\" , \"Daphnee:PSISr\" ] markers = Markers . from_csv ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels ) Or by position: channels = [ 5 , 6 , 7 ] markers = Markers . from_csv ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels ) Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify prefix_delimiter and suffix_delimiter for the suffix. For example, if the name is \"Daphnee:ASISr\" and you specify suffix_delimiter=\":\" , you will select \"Daphnee\". Similarly, if you specify `prefix_delimiter=\":\": channels = [ \"ASISr\" , \"ASISl\" , \"PSISr\" ] markers = Markers . from_csv ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels , prefix_delimiter = \":\" , ) It is also possible to specify a column containing the time vector: markers = Markers . from_csv ( data_path , header = 2 , first_row = 5 , first_column = 1 , time_column = 0 ) Source code in pyomeca/markers.py @classmethod def from_csv ( cls , filename : Union [ str , Path ], usecols : Optional [ List [ Union [ str , int ]]] = None , header : Optional [ int ] = None , first_row : int = 0 , first_column : Optional [ Union [ str , int ]] = None , time_column : Optional [ Union [ str , int ]] = None , trailing_columns : Optional [ Union [ str , int ]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , skip_rows : Optional [ List [ int ]] = None , pandas_kwargs : Optional [ dict ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Markers DataArray from a csv file. Arguments: filename: Any valid string path usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. header: Row of the header (0-indexed) first_row: First row of the data (0-indexed) first_column: First column of the data (0-indexed) time_column: Location of the time column. If None, indices are associated trailing_columns: If for some reason the csv reads extra columns, how many should be ignored prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) skip_rows: Line numbers to skip (0-indexed) pandas_kwargs: Keyword arguments to be passed to `pandas.read_csv` attrs: attrs to be passed to `xr.DataArray`. If attrs['rate'] is provided, compute the time accordingly Returns: Markers `xarray.DataArray` with the specified data and coordinates !!! example To read [this csv file](https://github.com/pyomeca/pyomeca/blob/master/tests/data/markers.csv), type: ```python from pyomeca import Markers data_path = \"./tests/data/markers.csv\" markers = Markers.from_csv(data_path, header=2, first_row=5, first_column=2) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"Daphnee:ASISr\", \"Daphnee:ASISl\", \"Daphnee:PSISr\"] markers = Markers.from_csv( data_path, header=2, first_row=5, first_column=2, usecols=channels ) ``` Or by position: ```python channels = [5, 6, 7] markers = Markers.from_csv( data_path, header=2, first_row=5, first_column=2, usecols=channels ) ``` Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify `prefix_delimiter` and `suffix_delimiter` for the suffix. For example, if the name is `\"Daphnee:ASISr\"` and you specify `suffix_delimiter=\":\"`, you will select \"Daphnee\". Similarly, if you specify `prefix_delimiter=\":\": ```python channels = [\"ASISr\", \"ASISl\", \"PSISr\"] markers = Markers.from_csv( data_path, header=2, first_row=5, first_column=2, usecols=channels, prefix_delimiter=\":\", ) ``` It is also possible to specify a column containing the time vector: ```python markers = Markers.from_csv( data_path, header=2, first_row=5, first_column=1, time_column=0 ) ``` \"\"\" return read . read_csv_or_excel ( cls , \"csv\" , filename , usecols , header , first_row , first_column , time_column , trailing_columns , prefix_delimiter , suffix_delimiter , skip_rows , pandas_kwargs , attrs , ) from_excel ( filename , sheet_name = 0 , usecols = None , header = None , first_row = 0 , first_column = None , time_column = None , trailing_columns = None , prefix_delimiter = None , suffix_delimiter = None , skip_rows = None , pandas_kwargs = None , attrs = None ) classmethod Markers DataArray from an Excel file. Parameters: Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required sheet_name Union[str, int] Strings are used for sheet names. Integers are used in zero-indexed sheet positions 0 usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. None header Optional[int] Row of the header (0-indexed) None first_row int First row of the data (0-indexed) 0 first_column Optional[Union[str, int]] First column of the data (0-indexed) None time_column Optional[Union[str, int]] Location of the time column. If None, indices are associated None trailing_columns Optional[Union[str, int]] If for some reason the csv reads extra columns, how many should be ignored None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None skip_rows Optional[List[int]] Line numbers to skip (0-indexed) None pandas_kwargs Optional[dict] Keyword arguments to be passed to pandas.read_excel None attrs Optional[dict] attrs to be passed to xr.DataArray . If attrs['rate'] is provided, compute the time accordingly None Returns: Type Description DataArray Markers xarray.DataArray with the specified data and coordinates Example To read this excel file , type: from pyomeca import Markers data_path = \"./tests/data/markers.xlsx\" markers = Markers . from_excel ( data_path , header = 2 , first_row = 5 , first_column = 2 ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"boite:gauche_ext\" ] markers = Markers . from_excel ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels ) Or by position: channels = [ 1 ] markers = Markers . from_excel ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels ) Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify prefix_delimiter and suffix_delimiter for the suffix. For example, if the name is \"boite:gauche_ext\" and you specify suffix_delimiter=\":\" , you will select \"boite\". Similarly, if you specify `prefix_delimiter=\":\": channels = [ \"gauche_ext\" ] markers = Markers . from_excel ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels , prefix_delimiter = \":\" , ) It is also possible to specify a column containing the time vector: markers = Markers . from_excel ( data_path , header = 2 , first_row = 5 , first_column = 1 , time_column = 0 ) Source code in pyomeca/markers.py @classmethod def from_excel ( cls , filename : Union [ str , Path ], sheet_name : Union [ str , int ] = 0 , usecols : Optional [ List [ Union [ str , int ]]] = None , header : Optional [ int ] = None , first_row : int = 0 , first_column : Optional [ Union [ str , int ]] = None , time_column : Optional [ Union [ str , int ]] = None , trailing_columns : Optional [ Union [ str , int ]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , skip_rows : Optional [ List [ int ]] = None , pandas_kwargs : Optional [ dict ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Markers DataArray from an Excel file. Arguments: filename: Any valid string path sheet_name: Strings are used for sheet names. Integers are used in zero-indexed sheet positions usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. header: Row of the header (0-indexed) first_row: First row of the data (0-indexed) first_column: First column of the data (0-indexed) time_column: Location of the time column. If None, indices are associated trailing_columns: If for some reason the csv reads extra columns, how many should be ignored prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) skip_rows: Line numbers to skip (0-indexed) pandas_kwargs: Keyword arguments to be passed to `pandas.read_excel` attrs: attrs to be passed to `xr.DataArray`. If attrs['rate'] is provided, compute the time accordingly Returns: Markers `xarray.DataArray` with the specified data and coordinates !!! example To read [this excel file](https://github.com/pyomeca/pyomeca/blob/master/tests/data/markers.xlsx), type: ```python from pyomeca import Markers data_path = \"./tests/data/markers.xlsx\" markers = Markers.from_excel(data_path, header=2, first_row=5, first_column=2) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"boite:gauche_ext\"] markers = Markers.from_excel( data_path, header=2, first_row=5, first_column=2, usecols=channels ) ``` Or by position: ```python channels = [1] markers = Markers.from_excel( data_path, header=2, first_row=5, first_column=2, usecols=channels ) ``` Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify `prefix_delimiter` and `suffix_delimiter` for the suffix. For example, if the name is `\"boite:gauche_ext\"` and you specify `suffix_delimiter=\":\"`, you will select \"boite\". Similarly, if you specify `prefix_delimiter=\":\": ```python channels = [\"gauche_ext\"] markers = Markers.from_excel( data_path, header=2, first_row=5, first_column=2, usecols=channels, prefix_delimiter=\":\", ) ``` It is also possible to specify a column containing the time vector: ```python markers = Markers.from_excel( data_path, header=2, first_row=5, first_column=1, time_column=0 ) ``` \"\"\" return read . read_csv_or_excel ( cls , \"excel\" , filename , usecols , header , first_row , first_column , time_column , trailing_columns , prefix_delimiter , suffix_delimiter , skip_rows , pandas_kwargs , attrs , sheet_name , ) from_random_data ( distribution = 'normal' , size = ( 3 , 10 , 100 ), ** kwargs ) classmethod Create random data from a specified distribution (normal by default) using random walk. Parameters: Name Type Description Default distribution str Distribution available in numpy.random 'normal' size tuple Shape of the desired array (3, 10, 100) kwargs Keyword argument(s) to be passed to numpy.random. distribution {} Returns: Type Description DataArray Random markers xarray.DataArray sampled from a given distribution Example To instantiate a Markers with some random data sampled from a normal distribution: from pyomeca import Markers n_axis = 3 n_channels = 10 n_frames = 100 size = n_axis , n_channels , n_frames markers = Markers . from_random_data ( size = size ) You can choose any distribution available in numpy.random : markers = Markers . from_random_data ( distribution = \"uniform\" , size = size , low = 1 , high = 10 ) Source code in pyomeca/markers.py @classmethod def from_random_data ( cls , distribution : str = \"normal\" , size : tuple = ( 3 , 10 , 100 ), ** kwargs ) -> xr . DataArray : \"\"\" Create random data from a specified distribution (normal by default) using random walk. Arguments: distribution: Distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions) size: Shape of the desired array kwargs: Keyword argument(s) to be passed to numpy.random.`distribution` Returns: Random markers `xarray.DataArray` sampled from a given distribution !!! example To instantiate a `Markers` with some random data sampled from a normal distribution: ```python from pyomeca import Markers n_axis = 3 n_channels = 10 n_frames = 100 size = n_axis, n_channels, n_frames markers = Markers.from_random_data(size=size) ``` You can choose any distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions): ```python markers = Markers.from_random_data(distribution=\"uniform\", size=size, low=1, high=10) ``` \"\"\" return Markers ( getattr ( np . random , distribution )( size = size , ** kwargs ) . cumsum ( - 1 )) from_rototrans ( markers , rt ) classmethod Rotates markers data from a rototrans matrix. Parameters: Name Type Description Default markers DataArray markers array to rotate required rt DataArray Rototrans to rotate about required Returns: Type Description DataArray A rotated xarray.DataArray Example To rotate a random markers set from random angles: from pyomeca import Angles , Rototrans , Markers n_frames = 100 n_markers = 10 angles = Angles . from_random_data ( size = ( 3 , 1 , n_frames )) rt = Rototrans . from_euler_angles ( angles , \"xyz\" ) markers = Markers . from_random_data ( size = ( 3 , n_markers , n_frames )) rotated_markers = Markers . from_rototrans ( markers , rt ) Source code in pyomeca/markers.py @classmethod def from_rototrans ( cls , markers : xr . DataArray , rt : xr . DataArray ) -> xr . DataArray : \"\"\" Rotates markers data from a rototrans matrix. Arguments: markers: markers array to rotate rt: Rototrans to rotate about Returns: A rotated `xarray.DataArray` !!! example To rotate a random markers set from random angles: ```python from pyomeca import Angles, Rototrans, Markers n_frames = 100 n_markers = 10 angles = Angles.from_random_data(size=(3, 1, n_frames)) rt = Rototrans.from_euler_angles(angles, \"xyz\") markers = Markers.from_random_data(size=(3, n_markers, n_frames)) rotated_markers = Markers.from_rototrans(markers, rt) ``` \"\"\" return markers_from_rototrans ( markers , rt ) from_trc ( filename , ** kwargs ) classmethod Markers DataArray from a trc file. Parameters: Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required kwargs Keyword arguments to be passed to from_csv {} Returns: Type Description DataArray Markers xarray.DataArray with the specified data and coordinates Example To read this trc file , type: from pyomeca import Markers data_path = \"./tests/data/markers.trc\" markers = Markers . from_trc ( data_path ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"STER\" , \"STERl\" ] markers = Markers . from_trc ( data_path , usecols = channels ) Or by position: channels = [ 3 , 4 ] markers = Markers . from_trc ( data_path , usecols = channels ) Source code in pyomeca/markers.py @classmethod def from_trc ( cls , filename : Union [ str , Path ], ** kwargs ) -> xr . DataArray : \"\"\" Markers DataArray from a trc file. Arguments: filename: Any valid string path kwargs: Keyword arguments to be passed to `from_csv` Returns: Markers `xarray.DataArray` with the specified data and coordinates !!! example To read [this trc file](https://github.com/pyomeca/pyomeca/blob/master/tests/data/markers.trc), type: ```python from pyomeca import Markers data_path = \"./tests/data/markers.trc\" markers = Markers.from_trc(data_path) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"STER\", \"STERl\"] markers = Markers.from_trc(data_path, usecols=channels) ``` Or by position: ```python channels = [3, 4] markers = Markers.from_trc(data_path, usecols=channels) ``` \"\"\" return read . read_trc ( cls , filename , ** kwargs )","title":"Markers"},{"location":"api/markers/#markerspy","text":"","title":"markers.py"},{"location":"api/markers/#pyomeca.markers","text":"","title":"pyomeca.markers"},{"location":"api/markers/#pyomeca.markers.Markers","text":"","title":"Markers"},{"location":"api/markers/#pyomeca.markers.Markers.__new__","text":"Markers DataArray with axis , channel and time dimensions used for skin marker positions. Parameters: Name Type Description Default data Optional[Union[<built-in function array>, numpy.ndarray, xarray.core.dataarray.DataArray]] Array to be passed to xarray.DataArray None channels Optional[list] Channel names None time Optional[Union[<built-in function array>, list, pandas.core.series.Series]] Time vector in seconds associated with the data parameter None kwargs Keyword argument(s) to be passed to xarray.DataArray {} Returns: Type Description DataArray Markers xarray.DataArray with the specified data and coordinates Example To instantiate a Markers with 4 channels and 100 frames filled with some random data: import numpy as np from pyomeca import Markers n_axis = 3 n_channels = 4 n_frames = 100 data = np . random . random ( size = ( n_axis , n_channels , n_frames )) markers = Markers ( data ) You can add the channel names: names = [ \"A\" , \"B\" , \"C\" , \"D\" ] markers = Markers ( data , channels = names ) And an associate time vector: rate = 100 # Hz time = np . arange ( start = 0 , stop = n_frames / rate , step = 1 / rate ) markers = Markers ( data , channels = names , time = time ) Note Calling Markers() generate an empty array. Source code in pyomeca/markers.py def __new__ ( cls , data : Optional [ Union [ np . array , np . ndarray , xr . DataArray ]] = None , channels : Optional [ list ] = None , time : Optional [ Union [ np . array , list , pd . Series ]] = None , ** kwargs , ) -> xr . DataArray : \"\"\" Markers DataArray with `axis`, `channel` and `time` dimensions used for skin marker positions. ![markers](/images/objects/markers.svg) Arguments: data: Array to be passed to xarray.DataArray channels: Channel names time: Time vector in seconds associated with the `data` parameter kwargs: Keyword argument(s) to be passed to xarray.DataArray Returns: Markers `xarray.DataArray` with the specified data and coordinates !!! example To instantiate a `Markers` with 4 channels and 100 frames filled with some random data: ```python import numpy as np from pyomeca import Markers n_axis = 3 n_channels = 4 n_frames = 100 data = np.random.random(size=(n_axis, n_channels, n_frames)) markers = Markers(data) ``` You can add the channel names: ```python names = [\"A\", \"B\", \"C\", \"D\"] markers = Markers(data, channels=names) ``` And an associate time vector: ```python rate = 100 # Hz time = np.arange(start=0, stop=n_frames / rate, step=1 / rate) markers = Markers(data, channels=names, time=time) ``` !!! note Calling `Markers()` generate an empty array. \"\"\" coords = {} if data is None : data = np . ndarray (( 0 , 0 , 0 )) else : coords [ \"axis\" ] = [ \"x\" , \"y\" , \"z\" , \"ones\" ] if data . shape [ 0 ] == 3 : data = np . insert ( data , obj = 3 , values = 1 , axis = 0 ) if channels : coords [ \"channel\" ] = channels if time is not None : coords [ \"time\" ] = time return xr . DataArray ( data = data , dims = ( \"axis\" , \"channel\" , \"time\" ), coords = coords , name = \"markers\" , ** kwargs , )","title":"__new__()"},{"location":"api/markers/#pyomeca.markers.Markers.from_c3d","text":"Markers DataArray from a c3d file. Parameters: Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None attrs Optional[dict] attrs to be passed to xr.DataArray None Returns: Type Description DataArray Markers xarray.DataArray with the specified data and coordinates Example To read this c3d file , type: from pyomeca import Markers data_path = \"./tests/data/markers_analogs.c3d\" markers = Markers . from_c3d ( data_path ) If you know the channel names, you can retrieve only the ones you are interested in: channels = [ \"Daphnee:ASISl\" , \"Daphnee:PSISr\" , \"Daphnee:PSISl\" ] markers = Markers . from_c3d ( data_path , usecols = channels ) Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify prefix_delimiter and suffix_delimiter for the suffix. For example, if the name is \"\"Daphnee:ASISl\" and you specify suffix_delimiter=\":\" , you will select \"Daphnee\". Similarly, if you specify `prefix_delimiter=\":\": channels = [ \"ASISl\" , \"PSISr\" , \"PSISl\" ] markers = Markers . from_c3d ( data_path , prefix_delimiter = \":\" ) Source code in pyomeca/markers.py @classmethod def from_c3d ( cls , filename : Union [ str , Path ], usecols : Optional [ List [ Union [ str , int ]]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Markers DataArray from a c3d file. Arguments: filename: Any valid string path usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) attrs: attrs to be passed to xr.DataArray Returns: Markers `xarray.DataArray` with the specified data and coordinates !!! example To read [this c3d file](https://github.com/pyomeca/pyomeca/blob/master/tests/data/markers_analogs.c3d), type: ```python from pyomeca import Markers data_path = \"./tests/data/markers_analogs.c3d\" markers = Markers.from_c3d(data_path) ``` If you know the channel names, you can retrieve only the ones you are interested in: ```python channels = [\"Daphnee:ASISl\", \"Daphnee:PSISr\", \"Daphnee:PSISl\"] markers = Markers.from_c3d(data_path, usecols=channels) ``` Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify `prefix_delimiter` and `suffix_delimiter` for the suffix. For example, if the name is `\"\"Daphnee:ASISl\"` and you specify `suffix_delimiter=\":\"`, you will select \"Daphnee\". Similarly, if you specify `prefix_delimiter=\":\": ```python channels = [\"ASISl\", \"PSISr\", \"PSISl\"] markers = Markers.from_c3d(data_path, prefix_delimiter=\":\") ``` \"\"\" return read . read_c3d ( cls , filename , usecols , prefix_delimiter , suffix_delimiter , attrs )","title":"from_c3d()"},{"location":"api/markers/#pyomeca.markers.Markers.from_csv","text":"Markers DataArray from a csv file. Parameters: Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. None header Optional[int] Row of the header (0-indexed) None first_row int First row of the data (0-indexed) 0 first_column Optional[Union[str, int]] First column of the data (0-indexed) None time_column Optional[Union[str, int]] Location of the time column. If None, indices are associated None trailing_columns Optional[Union[str, int]] If for some reason the csv reads extra columns, how many should be ignored None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None skip_rows Optional[List[int]] Line numbers to skip (0-indexed) None pandas_kwargs Optional[dict] Keyword arguments to be passed to pandas.read_csv None attrs Optional[dict] attrs to be passed to xr.DataArray . If attrs['rate'] is provided, compute the time accordingly None Returns: Type Description DataArray Markers xarray.DataArray with the specified data and coordinates Example To read this csv file , type: from pyomeca import Markers data_path = \"./tests/data/markers.csv\" markers = Markers . from_csv ( data_path , header = 2 , first_row = 5 , first_column = 2 ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"Daphnee:ASISr\" , \"Daphnee:ASISl\" , \"Daphnee:PSISr\" ] markers = Markers . from_csv ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels ) Or by position: channels = [ 5 , 6 , 7 ] markers = Markers . from_csv ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels ) Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify prefix_delimiter and suffix_delimiter for the suffix. For example, if the name is \"Daphnee:ASISr\" and you specify suffix_delimiter=\":\" , you will select \"Daphnee\". Similarly, if you specify `prefix_delimiter=\":\": channels = [ \"ASISr\" , \"ASISl\" , \"PSISr\" ] markers = Markers . from_csv ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels , prefix_delimiter = \":\" , ) It is also possible to specify a column containing the time vector: markers = Markers . from_csv ( data_path , header = 2 , first_row = 5 , first_column = 1 , time_column = 0 ) Source code in pyomeca/markers.py @classmethod def from_csv ( cls , filename : Union [ str , Path ], usecols : Optional [ List [ Union [ str , int ]]] = None , header : Optional [ int ] = None , first_row : int = 0 , first_column : Optional [ Union [ str , int ]] = None , time_column : Optional [ Union [ str , int ]] = None , trailing_columns : Optional [ Union [ str , int ]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , skip_rows : Optional [ List [ int ]] = None , pandas_kwargs : Optional [ dict ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Markers DataArray from a csv file. Arguments: filename: Any valid string path usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. header: Row of the header (0-indexed) first_row: First row of the data (0-indexed) first_column: First column of the data (0-indexed) time_column: Location of the time column. If None, indices are associated trailing_columns: If for some reason the csv reads extra columns, how many should be ignored prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) skip_rows: Line numbers to skip (0-indexed) pandas_kwargs: Keyword arguments to be passed to `pandas.read_csv` attrs: attrs to be passed to `xr.DataArray`. If attrs['rate'] is provided, compute the time accordingly Returns: Markers `xarray.DataArray` with the specified data and coordinates !!! example To read [this csv file](https://github.com/pyomeca/pyomeca/blob/master/tests/data/markers.csv), type: ```python from pyomeca import Markers data_path = \"./tests/data/markers.csv\" markers = Markers.from_csv(data_path, header=2, first_row=5, first_column=2) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"Daphnee:ASISr\", \"Daphnee:ASISl\", \"Daphnee:PSISr\"] markers = Markers.from_csv( data_path, header=2, first_row=5, first_column=2, usecols=channels ) ``` Or by position: ```python channels = [5, 6, 7] markers = Markers.from_csv( data_path, header=2, first_row=5, first_column=2, usecols=channels ) ``` Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify `prefix_delimiter` and `suffix_delimiter` for the suffix. For example, if the name is `\"Daphnee:ASISr\"` and you specify `suffix_delimiter=\":\"`, you will select \"Daphnee\". Similarly, if you specify `prefix_delimiter=\":\": ```python channels = [\"ASISr\", \"ASISl\", \"PSISr\"] markers = Markers.from_csv( data_path, header=2, first_row=5, first_column=2, usecols=channels, prefix_delimiter=\":\", ) ``` It is also possible to specify a column containing the time vector: ```python markers = Markers.from_csv( data_path, header=2, first_row=5, first_column=1, time_column=0 ) ``` \"\"\" return read . read_csv_or_excel ( cls , \"csv\" , filename , usecols , header , first_row , first_column , time_column , trailing_columns , prefix_delimiter , suffix_delimiter , skip_rows , pandas_kwargs , attrs , )","title":"from_csv()"},{"location":"api/markers/#pyomeca.markers.Markers.from_excel","text":"Markers DataArray from an Excel file. Parameters: Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required sheet_name Union[str, int] Strings are used for sheet names. Integers are used in zero-indexed sheet positions 0 usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. None header Optional[int] Row of the header (0-indexed) None first_row int First row of the data (0-indexed) 0 first_column Optional[Union[str, int]] First column of the data (0-indexed) None time_column Optional[Union[str, int]] Location of the time column. If None, indices are associated None trailing_columns Optional[Union[str, int]] If for some reason the csv reads extra columns, how many should be ignored None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None skip_rows Optional[List[int]] Line numbers to skip (0-indexed) None pandas_kwargs Optional[dict] Keyword arguments to be passed to pandas.read_excel None attrs Optional[dict] attrs to be passed to xr.DataArray . If attrs['rate'] is provided, compute the time accordingly None Returns: Type Description DataArray Markers xarray.DataArray with the specified data and coordinates Example To read this excel file , type: from pyomeca import Markers data_path = \"./tests/data/markers.xlsx\" markers = Markers . from_excel ( data_path , header = 2 , first_row = 5 , first_column = 2 ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"boite:gauche_ext\" ] markers = Markers . from_excel ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels ) Or by position: channels = [ 1 ] markers = Markers . from_excel ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels ) Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify prefix_delimiter and suffix_delimiter for the suffix. For example, if the name is \"boite:gauche_ext\" and you specify suffix_delimiter=\":\" , you will select \"boite\". Similarly, if you specify `prefix_delimiter=\":\": channels = [ \"gauche_ext\" ] markers = Markers . from_excel ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels , prefix_delimiter = \":\" , ) It is also possible to specify a column containing the time vector: markers = Markers . from_excel ( data_path , header = 2 , first_row = 5 , first_column = 1 , time_column = 0 ) Source code in pyomeca/markers.py @classmethod def from_excel ( cls , filename : Union [ str , Path ], sheet_name : Union [ str , int ] = 0 , usecols : Optional [ List [ Union [ str , int ]]] = None , header : Optional [ int ] = None , first_row : int = 0 , first_column : Optional [ Union [ str , int ]] = None , time_column : Optional [ Union [ str , int ]] = None , trailing_columns : Optional [ Union [ str , int ]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , skip_rows : Optional [ List [ int ]] = None , pandas_kwargs : Optional [ dict ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Markers DataArray from an Excel file. Arguments: filename: Any valid string path sheet_name: Strings are used for sheet names. Integers are used in zero-indexed sheet positions usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. header: Row of the header (0-indexed) first_row: First row of the data (0-indexed) first_column: First column of the data (0-indexed) time_column: Location of the time column. If None, indices are associated trailing_columns: If for some reason the csv reads extra columns, how many should be ignored prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) skip_rows: Line numbers to skip (0-indexed) pandas_kwargs: Keyword arguments to be passed to `pandas.read_excel` attrs: attrs to be passed to `xr.DataArray`. If attrs['rate'] is provided, compute the time accordingly Returns: Markers `xarray.DataArray` with the specified data and coordinates !!! example To read [this excel file](https://github.com/pyomeca/pyomeca/blob/master/tests/data/markers.xlsx), type: ```python from pyomeca import Markers data_path = \"./tests/data/markers.xlsx\" markers = Markers.from_excel(data_path, header=2, first_row=5, first_column=2) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"boite:gauche_ext\"] markers = Markers.from_excel( data_path, header=2, first_row=5, first_column=2, usecols=channels ) ``` Or by position: ```python channels = [1] markers = Markers.from_excel( data_path, header=2, first_row=5, first_column=2, usecols=channels ) ``` Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify `prefix_delimiter` and `suffix_delimiter` for the suffix. For example, if the name is `\"boite:gauche_ext\"` and you specify `suffix_delimiter=\":\"`, you will select \"boite\". Similarly, if you specify `prefix_delimiter=\":\": ```python channels = [\"gauche_ext\"] markers = Markers.from_excel( data_path, header=2, first_row=5, first_column=2, usecols=channels, prefix_delimiter=\":\", ) ``` It is also possible to specify a column containing the time vector: ```python markers = Markers.from_excel( data_path, header=2, first_row=5, first_column=1, time_column=0 ) ``` \"\"\" return read . read_csv_or_excel ( cls , \"excel\" , filename , usecols , header , first_row , first_column , time_column , trailing_columns , prefix_delimiter , suffix_delimiter , skip_rows , pandas_kwargs , attrs , sheet_name , )","title":"from_excel()"},{"location":"api/markers/#pyomeca.markers.Markers.from_random_data","text":"Create random data from a specified distribution (normal by default) using random walk. Parameters: Name Type Description Default distribution str Distribution available in numpy.random 'normal' size tuple Shape of the desired array (3, 10, 100) kwargs Keyword argument(s) to be passed to numpy.random. distribution {} Returns: Type Description DataArray Random markers xarray.DataArray sampled from a given distribution Example To instantiate a Markers with some random data sampled from a normal distribution: from pyomeca import Markers n_axis = 3 n_channels = 10 n_frames = 100 size = n_axis , n_channels , n_frames markers = Markers . from_random_data ( size = size ) You can choose any distribution available in numpy.random : markers = Markers . from_random_data ( distribution = \"uniform\" , size = size , low = 1 , high = 10 ) Source code in pyomeca/markers.py @classmethod def from_random_data ( cls , distribution : str = \"normal\" , size : tuple = ( 3 , 10 , 100 ), ** kwargs ) -> xr . DataArray : \"\"\" Create random data from a specified distribution (normal by default) using random walk. Arguments: distribution: Distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions) size: Shape of the desired array kwargs: Keyword argument(s) to be passed to numpy.random.`distribution` Returns: Random markers `xarray.DataArray` sampled from a given distribution !!! example To instantiate a `Markers` with some random data sampled from a normal distribution: ```python from pyomeca import Markers n_axis = 3 n_channels = 10 n_frames = 100 size = n_axis, n_channels, n_frames markers = Markers.from_random_data(size=size) ``` You can choose any distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions): ```python markers = Markers.from_random_data(distribution=\"uniform\", size=size, low=1, high=10) ``` \"\"\" return Markers ( getattr ( np . random , distribution )( size = size , ** kwargs ) . cumsum ( - 1 ))","title":"from_random_data()"},{"location":"api/markers/#pyomeca.markers.Markers.from_rototrans","text":"Rotates markers data from a rototrans matrix. Parameters: Name Type Description Default markers DataArray markers array to rotate required rt DataArray Rototrans to rotate about required Returns: Type Description DataArray A rotated xarray.DataArray Example To rotate a random markers set from random angles: from pyomeca import Angles , Rototrans , Markers n_frames = 100 n_markers = 10 angles = Angles . from_random_data ( size = ( 3 , 1 , n_frames )) rt = Rototrans . from_euler_angles ( angles , \"xyz\" ) markers = Markers . from_random_data ( size = ( 3 , n_markers , n_frames )) rotated_markers = Markers . from_rototrans ( markers , rt ) Source code in pyomeca/markers.py @classmethod def from_rototrans ( cls , markers : xr . DataArray , rt : xr . DataArray ) -> xr . DataArray : \"\"\" Rotates markers data from a rototrans matrix. Arguments: markers: markers array to rotate rt: Rototrans to rotate about Returns: A rotated `xarray.DataArray` !!! example To rotate a random markers set from random angles: ```python from pyomeca import Angles, Rototrans, Markers n_frames = 100 n_markers = 10 angles = Angles.from_random_data(size=(3, 1, n_frames)) rt = Rototrans.from_euler_angles(angles, \"xyz\") markers = Markers.from_random_data(size=(3, n_markers, n_frames)) rotated_markers = Markers.from_rototrans(markers, rt) ``` \"\"\" return markers_from_rototrans ( markers , rt )","title":"from_rototrans()"},{"location":"api/markers/#pyomeca.markers.Markers.from_trc","text":"Markers DataArray from a trc file. Parameters: Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required kwargs Keyword arguments to be passed to from_csv {} Returns: Type Description DataArray Markers xarray.DataArray with the specified data and coordinates Example To read this trc file , type: from pyomeca import Markers data_path = \"./tests/data/markers.trc\" markers = Markers . from_trc ( data_path ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"STER\" , \"STERl\" ] markers = Markers . from_trc ( data_path , usecols = channels ) Or by position: channels = [ 3 , 4 ] markers = Markers . from_trc ( data_path , usecols = channels ) Source code in pyomeca/markers.py @classmethod def from_trc ( cls , filename : Union [ str , Path ], ** kwargs ) -> xr . DataArray : \"\"\" Markers DataArray from a trc file. Arguments: filename: Any valid string path kwargs: Keyword arguments to be passed to `from_csv` Returns: Markers `xarray.DataArray` with the specified data and coordinates !!! example To read [this trc file](https://github.com/pyomeca/pyomeca/blob/master/tests/data/markers.trc), type: ```python from pyomeca import Markers data_path = \"./tests/data/markers.trc\" markers = Markers.from_trc(data_path) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"STER\", \"STERl\"] markers = Markers.from_trc(data_path, usecols=channels) ``` Or by position: ```python channels = [3, 4] markers = Markers.from_trc(data_path, usecols=channels) ``` \"\"\" return read . read_trc ( cls , filename , ** kwargs )","title":"from_trc()"},{"location":"api/rototrans/","text":"rototrans.py Rototrans __new__ ( cls , data = None , time = None , ** kwargs ) special staticmethod Rototrans DataArray with row , col and time dimensions used for rototranslation matrix. Parameters: Name Type Description Default data Optional[Union[<built-in function array>, numpy.ndarray, xarray.core.dataarray.DataArray]] Array to be passed to xarray.DataArray None time Optional[Union[<built-in function array>, list, pandas.core.series.Series]] Time vector in seconds associated with the data parameter None kwargs Keyword argument(s) to be passed to xarray.DataArray {} Returns: Type Description DataArray Rototrans xarray.DataArray with the specified data and coordinates Example To instantiate a Rototrans 4 by 4 and 100 frames filled with some random data: from pyomeca import Rototrans import numpy as np # create random yet homogeneous data n_frames = 100 data = Rototrans . from_random_data ( size = ( 4 , 4 , 100 )) . data rt = Rototrans ( data ) You can an associate time vector: rate = 100 # Hz time = np . arange ( start = 0 , stop = n_frames / rate , step = 1 / rate ) rt = Rototrans ( data , time = time ) Notes Calling Rototrans() generate an empty array. Source code in pyomeca/rototrans.py def __new__ ( cls , data : Optional [ Union [ np . array , np . ndarray , xr . DataArray ]] = None , time : Optional [ Union [ np . array , list , pd . Series ]] = None , ** kwargs , ) -> xr . DataArray : \"\"\" Rototrans DataArray with `row`, `col` and `time` dimensions used for rototranslation matrix. ![rototrans](/images/objects/rototrans.svg) Arguments: data: Array to be passed to xarray.DataArray time: Time vector in seconds associated with the `data` parameter kwargs: Keyword argument(s) to be passed to xarray.DataArray Returns: Rototrans `xarray.DataArray` with the specified data and coordinates !!! example To instantiate a `Rototrans` 4 by 4 and 100 frames filled with some random data: ```python from pyomeca import Rototrans import numpy as np # create random yet homogeneous data n_frames = 100 data = Rototrans.from_random_data(size=(4, 4, 100)).data rt = Rototrans(data) ``` You can an associate time vector: ```python rate = 100 # Hz time = np.arange(start=0, stop=n_frames / rate, step=1 / rate) rt = Rototrans(data, time=time) ``` !!! notes Calling `Rototrans()` generate an empty array. \"\"\" coords = {} if data is None : data = np . eye ( 4 ) else : # if we provide data, we copy them to avoid making inplace changes data = data . copy () if data . shape [ 0 ] not in ( 3 , 4 ) or data . shape [ 0 ] != data . shape [ 1 ]: raise IndexError ( f \"data must have first and second dimensions of length 4, you have: { data . shape } \" ) if data . ndim == 2 : data = data [ ... , np . newaxis ] if time is not None : coords [ \"time\" ] = time # Make sure last line reads [0, 0, 0, 1] zeros = data [ 3 , : 3 , :] ones = data [ 3 , 3 , :] if not np . alltrue ( zeros == 0 ) or not np . alltrue ( ones == 1 ): some_zeros = np . random . choice ( zeros . ravel (), 5 ) some_ones = np . random . choice ( ones . ravel (), 5 ) raise ValueError ( \"Last line does not read [0, 0, 0, 1]. \\n \" f \"Here are some values that should be 0: { some_zeros } \\n \" f \"And others that should 1: { some_ones } \" ) return xr . DataArray ( data = data , dims = ( \"row\" , \"col\" , \"time\" ), coords = coords , name = \"rototrans\" , ** kwargs , ) from_averaged_rototrans ( rt ) classmethod Rototrans DataArray from an averaged Rototrans. Parameters: Name Type Description Default rt DataArray Rototrans to average required Returns: Type Description DataArray Averaged Rototrans xarray.DataArray Example To average a Rototrans computed from random angles: import numpy as np from pyomeca import Angles , Rototrans angles = Angles ( np . random . rand ( 3 , 1 , 100 )) seq = \"xyz\" rt = Rototrans . from_euler_angles ( angles , seq ) rt_mean = Rototrans . from_averaged_rototrans ( rt ) Let's make sure the resulting angles are roughly equivalent to the averaged angles: angles_mean = Angles . from_rototrans ( rt_mean , seq ) . isel ( time = 0 ) angles_mean_ref = Angles . from_rototrans ( rt , seq ) . mean ( dim = \"time\" ) error = ( angles_mean - angles_mean_ref ) . meca . abs () . sum () print ( error ) Source code in pyomeca/rototrans.py @classmethod def from_averaged_rototrans ( cls , rt : xr . DataArray ) -> xr . DataArray : \"\"\" Rototrans DataArray from an averaged Rototrans. Arguments: rt: Rototrans to average Returns: Averaged Rototrans `xarray.DataArray` !!! example To average a `Rototrans` computed from random angles: ```python import numpy as np from pyomeca import Angles, Rototrans angles = Angles(np.random.rand(3, 1, 100)) seq = \"xyz\" rt = Rototrans.from_euler_angles(angles, seq) rt_mean = Rototrans.from_averaged_rototrans(rt) ``` Let's make sure the resulting angles are roughly equivalent to the averaged angles: ```python angles_mean = Angles.from_rototrans(rt_mean, seq).isel(time=0) angles_mean_ref = Angles.from_rototrans(rt, seq).mean(dim=\"time\") error = (angles_mean - angles_mean_ref).meca.abs().sum() print(error) ``` \"\"\" return rototrans . rototrans_from_averaged_rototrans ( cls , rt ) from_euler_angles ( angles = None , angle_sequence = None , translations = None ) classmethod Rototrans DataArray from euler angles and specified angle sequence. Parameters: Name Type Description Default angles Optional[xarray.core.dataarray.DataArray] Euler angles of the rototranslation matrix None angle_sequence Optional[str] Euler sequence of angles. Valid values are all permutations of \"xyz\" None translations Optional[xarray.core.dataarray.DataArray] Translation part of the Rototrans matrix None Returns: Type Description DataArray Rototrans xarray.DataArray from the specified angles and angles sequence Example To get the rototranslation matrix from random euler angles with a given angle sequence type: from pyomeca import Angles , Rototrans size = ( 3 , 1 , 100 ) angles = Angles . from_random_data ( size = size ) angles_sequence = \"xyz\" rt = Rototrans . from_euler_angles ( angles = angles , angle_sequence = angles_sequence ) A translation vector can also be specified: translation = Angles . from_random_data ( size = size ) rt = Rototrans . from_euler_angles ( angles = angles , angle_sequence = angles_sequence , translations = translation ) Source code in pyomeca/rototrans.py @classmethod def from_euler_angles ( cls , angles : Optional [ xr . DataArray ] = None , angle_sequence : Optional [ str ] = None , translations : Optional [ xr . DataArray ] = None , ) -> xr . DataArray : \"\"\" Rototrans DataArray from euler angles and specified angle sequence. Arguments: angles: Euler angles of the rototranslation matrix angle_sequence: Euler sequence of angles. Valid values are all permutations of \"xyz\" translations: Translation part of the Rototrans matrix Returns: Rototrans `xarray.DataArray` from the specified angles and angles sequence !!! example To get the rototranslation matrix from random euler angles with a given angle sequence type: ```python from pyomeca import Angles, Rototrans size = (3, 1, 100) angles = Angles.from_random_data(size=size) angles_sequence = \"xyz\" rt = Rototrans.from_euler_angles(angles=angles, angle_sequence=angles_sequence) ``` A translation vector can also be specified: ```python translation = Angles.from_random_data(size=size) rt = Rototrans.from_euler_angles( angles=angles, angle_sequence=angles_sequence, translations=translation ) ``` \"\"\" return rototrans . rototrans_from_euler_angles ( cls , angles , angle_sequence , translations ) from_markers ( origin , axis_1 , axis_2 , axes_name , axis_to_recalculate ) classmethod Rototrans DataArray from a specified set of markers. Parameters: Name Type Description Default origin DataArray A marker constructed with pyomeca.Markers() corresponding to the origin in the global reference frame required axis_1 DataArray Two markers that describe the first axis. The first markers being the beginning of the vector and the second being the end. required axis_2 DataArray Two markers that describe the second axis. The first markers being the beginning of the vector and the second being the end. required axes_name str Any combination of x , y and z describing the first and second axes. required axis_to_recalculate str Which of the two axes to recalculate required Returns: Type Description DataArray Rototrans xarray.DataArray from the specified angles and angles sequence Example To create a system of axes from random markers: from pyomeca import Markers , Rototrans markers = Markers . from_random_data () rt = Rototrans . from_markers ( origin = markers . isel ( channel = [ 0 ]), # first marker axis_1 = markers . isel ( channel = [ 0 , 1 ]), # vector from the first and second markers axis_2 = markers . isel ( channel = [ 0 , 2 ]), # vector from the first and third markers axes_name = \"xy\" , # axis_1 is x and axis_2 is y axis_to_recalculate = \"y\" , # we want to recalculate y ) Source code in pyomeca/rototrans.py @classmethod def from_markers ( cls , origin : xr . DataArray , axis_1 : xr . DataArray , axis_2 : xr . DataArray , axes_name : str , axis_to_recalculate : str , ) -> xr . DataArray : \"\"\" Rototrans DataArray from a specified set of markers. Arguments: origin: A marker constructed with `pyomeca.Markers()` corresponding to the origin in the global reference frame axis_1: Two markers that describe the first axis. The first markers being the beginning of the vector and the second being the end. axis_2: Two markers that describe the second axis. The first markers being the beginning of the vector and the second being the end. axes_name: Any combination of `x`, `y` and `z` describing the first and second axes. axis_to_recalculate: Which of the two axes to recalculate Returns: Rototrans `xarray.DataArray` from the specified angles and angles sequence !!! example To create a system of axes from random markers: ```python from pyomeca import Markers, Rototrans markers = Markers.from_random_data() rt = Rototrans.from_markers( origin=markers.isel(channel=[0]), # first marker axis_1=markers.isel(channel=[0, 1]), # vector from the first and second markers axis_2=markers.isel(channel=[0, 2]), # vector from the first and third markers axes_name=\"xy\", # axis_1 is x and axis_2 is y axis_to_recalculate=\"y\", # we want to recalculate y ) ``` \"\"\" return rototrans . rototrans_from_markers ( cls , origin , axis_1 , axis_2 , axes_name , axis_to_recalculate ) from_random_data ( distribution = 'normal' , size = ( 3 , 1 , 100 ), ** kwargs ) classmethod Create random data from a specified distribution (normal by default) using random walk. Parameters: Name Type Description Default distribution str Distribution available in numpy.random 'normal' size tuple Shape of the desired array (3, 1, 100) kwargs Keyword argument(s) to be passed to numpy.random. distribution {} Returns: Type Description DataArray Random rototrans xarray.DataArray sampled from a given distribution Example To instantiate a Rototrans with some random data sampled from a normal distribution: from pyomeca import Rototrans n_frames = 100 size = 4 , 4 , n_frames rt = Rototrans . from_random_data ( size = size ) You can choose any distribution available in numpy.random : rt = Rototrans . from_random_data ( distribution = \"uniform\" , size = size , low = 1 , high = 10 ) Source code in pyomeca/rototrans.py @classmethod def from_random_data ( cls , distribution : str = \"normal\" , size : tuple = ( 3 , 1 , 100 ), ** kwargs ) -> xr . DataArray : \"\"\" Create random data from a specified distribution (normal by default) using random walk. Arguments: distribution: Distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions) size: Shape of the desired array kwargs: Keyword argument(s) to be passed to numpy.random.`distribution` Returns: Random rototrans `xarray.DataArray` sampled from a given distribution !!! example To instantiate a `Rototrans` with some random data sampled from a normal distribution: ```python from pyomeca import Rototrans n_frames = 100 size = 4, 4, n_frames rt = Rototrans.from_random_data(size=size) ``` You can choose any distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions): ```python rt = Rototrans.from_random_data(distribution=\"uniform\", size=size, low=1, high=10) ``` \"\"\" return Rototrans . from_euler_angles ( Angles . from_random_data ( distribution , size = ( 3 , 1 , size [ - 1 ]), ** kwargs ), \"xyz\" , ) from_transposed_rototrans ( rt ) classmethod Rototrans DataArray from a tranposed Rototrans. Parameters: Name Type Description Default rt DataArray Rototrans to transpose required Returns: Type Description DataArray Transposed Rototrans xarray.DataArray Example from pyomeca import Rototrans rt = Rototrans . from_random_data () rt_t = Rototrans . from_transposed_rototrans ( rt ) Notes The inverse Rototrans is, by definition, equivalent to the tranposed Rototrans. Source code in pyomeca/rototrans.py @classmethod def from_transposed_rototrans ( cls , rt : xr . DataArray ) -> xr . DataArray : \"\"\" Rototrans DataArray from a tranposed Rototrans. Arguments: rt: Rototrans to transpose Returns: Transposed Rototrans `xarray.DataArray` !!! example ```python from pyomeca import Rototrans rt = Rototrans.from_random_data() rt_t = Rototrans.from_transposed_rototrans(rt) ``` !!! notes The inverse Rototrans is, by definition, equivalent to the tranposed Rototrans. \"\"\" return rototrans . rototrans_from_transposed_rototrans ( cls , rt )","title":"Rototrans"},{"location":"api/rototrans/#rototranspy","text":"","title":"rototrans.py"},{"location":"api/rototrans/#pyomeca.rototrans","text":"","title":"pyomeca.rototrans"},{"location":"api/rototrans/#pyomeca.rototrans.Rototrans","text":"","title":"Rototrans"},{"location":"api/rototrans/#pyomeca.rototrans.Rototrans.__new__","text":"Rototrans DataArray with row , col and time dimensions used for rototranslation matrix. Parameters: Name Type Description Default data Optional[Union[<built-in function array>, numpy.ndarray, xarray.core.dataarray.DataArray]] Array to be passed to xarray.DataArray None time Optional[Union[<built-in function array>, list, pandas.core.series.Series]] Time vector in seconds associated with the data parameter None kwargs Keyword argument(s) to be passed to xarray.DataArray {} Returns: Type Description DataArray Rototrans xarray.DataArray with the specified data and coordinates Example To instantiate a Rototrans 4 by 4 and 100 frames filled with some random data: from pyomeca import Rototrans import numpy as np # create random yet homogeneous data n_frames = 100 data = Rototrans . from_random_data ( size = ( 4 , 4 , 100 )) . data rt = Rototrans ( data ) You can an associate time vector: rate = 100 # Hz time = np . arange ( start = 0 , stop = n_frames / rate , step = 1 / rate ) rt = Rototrans ( data , time = time ) Notes Calling Rototrans() generate an empty array. Source code in pyomeca/rototrans.py def __new__ ( cls , data : Optional [ Union [ np . array , np . ndarray , xr . DataArray ]] = None , time : Optional [ Union [ np . array , list , pd . Series ]] = None , ** kwargs , ) -> xr . DataArray : \"\"\" Rototrans DataArray with `row`, `col` and `time` dimensions used for rototranslation matrix. ![rototrans](/images/objects/rototrans.svg) Arguments: data: Array to be passed to xarray.DataArray time: Time vector in seconds associated with the `data` parameter kwargs: Keyword argument(s) to be passed to xarray.DataArray Returns: Rototrans `xarray.DataArray` with the specified data and coordinates !!! example To instantiate a `Rototrans` 4 by 4 and 100 frames filled with some random data: ```python from pyomeca import Rototrans import numpy as np # create random yet homogeneous data n_frames = 100 data = Rototrans.from_random_data(size=(4, 4, 100)).data rt = Rototrans(data) ``` You can an associate time vector: ```python rate = 100 # Hz time = np.arange(start=0, stop=n_frames / rate, step=1 / rate) rt = Rototrans(data, time=time) ``` !!! notes Calling `Rototrans()` generate an empty array. \"\"\" coords = {} if data is None : data = np . eye ( 4 ) else : # if we provide data, we copy them to avoid making inplace changes data = data . copy () if data . shape [ 0 ] not in ( 3 , 4 ) or data . shape [ 0 ] != data . shape [ 1 ]: raise IndexError ( f \"data must have first and second dimensions of length 4, you have: { data . shape } \" ) if data . ndim == 2 : data = data [ ... , np . newaxis ] if time is not None : coords [ \"time\" ] = time # Make sure last line reads [0, 0, 0, 1] zeros = data [ 3 , : 3 , :] ones = data [ 3 , 3 , :] if not np . alltrue ( zeros == 0 ) or not np . alltrue ( ones == 1 ): some_zeros = np . random . choice ( zeros . ravel (), 5 ) some_ones = np . random . choice ( ones . ravel (), 5 ) raise ValueError ( \"Last line does not read [0, 0, 0, 1]. \\n \" f \"Here are some values that should be 0: { some_zeros } \\n \" f \"And others that should 1: { some_ones } \" ) return xr . DataArray ( data = data , dims = ( \"row\" , \"col\" , \"time\" ), coords = coords , name = \"rototrans\" , ** kwargs , )","title":"__new__()"},{"location":"api/rototrans/#pyomeca.rototrans.Rototrans.from_averaged_rototrans","text":"Rototrans DataArray from an averaged Rototrans. Parameters: Name Type Description Default rt DataArray Rototrans to average required Returns: Type Description DataArray Averaged Rototrans xarray.DataArray Example To average a Rototrans computed from random angles: import numpy as np from pyomeca import Angles , Rototrans angles = Angles ( np . random . rand ( 3 , 1 , 100 )) seq = \"xyz\" rt = Rototrans . from_euler_angles ( angles , seq ) rt_mean = Rototrans . from_averaged_rototrans ( rt ) Let's make sure the resulting angles are roughly equivalent to the averaged angles: angles_mean = Angles . from_rototrans ( rt_mean , seq ) . isel ( time = 0 ) angles_mean_ref = Angles . from_rototrans ( rt , seq ) . mean ( dim = \"time\" ) error = ( angles_mean - angles_mean_ref ) . meca . abs () . sum () print ( error ) Source code in pyomeca/rototrans.py @classmethod def from_averaged_rototrans ( cls , rt : xr . DataArray ) -> xr . DataArray : \"\"\" Rototrans DataArray from an averaged Rototrans. Arguments: rt: Rototrans to average Returns: Averaged Rototrans `xarray.DataArray` !!! example To average a `Rototrans` computed from random angles: ```python import numpy as np from pyomeca import Angles, Rototrans angles = Angles(np.random.rand(3, 1, 100)) seq = \"xyz\" rt = Rototrans.from_euler_angles(angles, seq) rt_mean = Rototrans.from_averaged_rototrans(rt) ``` Let's make sure the resulting angles are roughly equivalent to the averaged angles: ```python angles_mean = Angles.from_rototrans(rt_mean, seq).isel(time=0) angles_mean_ref = Angles.from_rototrans(rt, seq).mean(dim=\"time\") error = (angles_mean - angles_mean_ref).meca.abs().sum() print(error) ``` \"\"\" return rototrans . rototrans_from_averaged_rototrans ( cls , rt )","title":"from_averaged_rototrans()"},{"location":"api/rototrans/#pyomeca.rototrans.Rototrans.from_euler_angles","text":"Rototrans DataArray from euler angles and specified angle sequence. Parameters: Name Type Description Default angles Optional[xarray.core.dataarray.DataArray] Euler angles of the rototranslation matrix None angle_sequence Optional[str] Euler sequence of angles. Valid values are all permutations of \"xyz\" None translations Optional[xarray.core.dataarray.DataArray] Translation part of the Rototrans matrix None Returns: Type Description DataArray Rototrans xarray.DataArray from the specified angles and angles sequence Example To get the rototranslation matrix from random euler angles with a given angle sequence type: from pyomeca import Angles , Rototrans size = ( 3 , 1 , 100 ) angles = Angles . from_random_data ( size = size ) angles_sequence = \"xyz\" rt = Rototrans . from_euler_angles ( angles = angles , angle_sequence = angles_sequence ) A translation vector can also be specified: translation = Angles . from_random_data ( size = size ) rt = Rototrans . from_euler_angles ( angles = angles , angle_sequence = angles_sequence , translations = translation ) Source code in pyomeca/rototrans.py @classmethod def from_euler_angles ( cls , angles : Optional [ xr . DataArray ] = None , angle_sequence : Optional [ str ] = None , translations : Optional [ xr . DataArray ] = None , ) -> xr . DataArray : \"\"\" Rototrans DataArray from euler angles and specified angle sequence. Arguments: angles: Euler angles of the rototranslation matrix angle_sequence: Euler sequence of angles. Valid values are all permutations of \"xyz\" translations: Translation part of the Rototrans matrix Returns: Rototrans `xarray.DataArray` from the specified angles and angles sequence !!! example To get the rototranslation matrix from random euler angles with a given angle sequence type: ```python from pyomeca import Angles, Rototrans size = (3, 1, 100) angles = Angles.from_random_data(size=size) angles_sequence = \"xyz\" rt = Rototrans.from_euler_angles(angles=angles, angle_sequence=angles_sequence) ``` A translation vector can also be specified: ```python translation = Angles.from_random_data(size=size) rt = Rototrans.from_euler_angles( angles=angles, angle_sequence=angles_sequence, translations=translation ) ``` \"\"\" return rototrans . rototrans_from_euler_angles ( cls , angles , angle_sequence , translations )","title":"from_euler_angles()"},{"location":"api/rototrans/#pyomeca.rototrans.Rototrans.from_markers","text":"Rototrans DataArray from a specified set of markers. Parameters: Name Type Description Default origin DataArray A marker constructed with pyomeca.Markers() corresponding to the origin in the global reference frame required axis_1 DataArray Two markers that describe the first axis. The first markers being the beginning of the vector and the second being the end. required axis_2 DataArray Two markers that describe the second axis. The first markers being the beginning of the vector and the second being the end. required axes_name str Any combination of x , y and z describing the first and second axes. required axis_to_recalculate str Which of the two axes to recalculate required Returns: Type Description DataArray Rototrans xarray.DataArray from the specified angles and angles sequence Example To create a system of axes from random markers: from pyomeca import Markers , Rototrans markers = Markers . from_random_data () rt = Rototrans . from_markers ( origin = markers . isel ( channel = [ 0 ]), # first marker axis_1 = markers . isel ( channel = [ 0 , 1 ]), # vector from the first and second markers axis_2 = markers . isel ( channel = [ 0 , 2 ]), # vector from the first and third markers axes_name = \"xy\" , # axis_1 is x and axis_2 is y axis_to_recalculate = \"y\" , # we want to recalculate y ) Source code in pyomeca/rototrans.py @classmethod def from_markers ( cls , origin : xr . DataArray , axis_1 : xr . DataArray , axis_2 : xr . DataArray , axes_name : str , axis_to_recalculate : str , ) -> xr . DataArray : \"\"\" Rototrans DataArray from a specified set of markers. Arguments: origin: A marker constructed with `pyomeca.Markers()` corresponding to the origin in the global reference frame axis_1: Two markers that describe the first axis. The first markers being the beginning of the vector and the second being the end. axis_2: Two markers that describe the second axis. The first markers being the beginning of the vector and the second being the end. axes_name: Any combination of `x`, `y` and `z` describing the first and second axes. axis_to_recalculate: Which of the two axes to recalculate Returns: Rototrans `xarray.DataArray` from the specified angles and angles sequence !!! example To create a system of axes from random markers: ```python from pyomeca import Markers, Rototrans markers = Markers.from_random_data() rt = Rototrans.from_markers( origin=markers.isel(channel=[0]), # first marker axis_1=markers.isel(channel=[0, 1]), # vector from the first and second markers axis_2=markers.isel(channel=[0, 2]), # vector from the first and third markers axes_name=\"xy\", # axis_1 is x and axis_2 is y axis_to_recalculate=\"y\", # we want to recalculate y ) ``` \"\"\" return rototrans . rototrans_from_markers ( cls , origin , axis_1 , axis_2 , axes_name , axis_to_recalculate )","title":"from_markers()"},{"location":"api/rototrans/#pyomeca.rototrans.Rototrans.from_random_data","text":"Create random data from a specified distribution (normal by default) using random walk. Parameters: Name Type Description Default distribution str Distribution available in numpy.random 'normal' size tuple Shape of the desired array (3, 1, 100) kwargs Keyword argument(s) to be passed to numpy.random. distribution {} Returns: Type Description DataArray Random rototrans xarray.DataArray sampled from a given distribution Example To instantiate a Rototrans with some random data sampled from a normal distribution: from pyomeca import Rototrans n_frames = 100 size = 4 , 4 , n_frames rt = Rototrans . from_random_data ( size = size ) You can choose any distribution available in numpy.random : rt = Rototrans . from_random_data ( distribution = \"uniform\" , size = size , low = 1 , high = 10 ) Source code in pyomeca/rototrans.py @classmethod def from_random_data ( cls , distribution : str = \"normal\" , size : tuple = ( 3 , 1 , 100 ), ** kwargs ) -> xr . DataArray : \"\"\" Create random data from a specified distribution (normal by default) using random walk. Arguments: distribution: Distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions) size: Shape of the desired array kwargs: Keyword argument(s) to be passed to numpy.random.`distribution` Returns: Random rototrans `xarray.DataArray` sampled from a given distribution !!! example To instantiate a `Rototrans` with some random data sampled from a normal distribution: ```python from pyomeca import Rototrans n_frames = 100 size = 4, 4, n_frames rt = Rototrans.from_random_data(size=size) ``` You can choose any distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions): ```python rt = Rototrans.from_random_data(distribution=\"uniform\", size=size, low=1, high=10) ``` \"\"\" return Rototrans . from_euler_angles ( Angles . from_random_data ( distribution , size = ( 3 , 1 , size [ - 1 ]), ** kwargs ), \"xyz\" , )","title":"from_random_data()"},{"location":"api/rototrans/#pyomeca.rototrans.Rototrans.from_transposed_rototrans","text":"Rototrans DataArray from a tranposed Rototrans. Parameters: Name Type Description Default rt DataArray Rototrans to transpose required Returns: Type Description DataArray Transposed Rototrans xarray.DataArray Example from pyomeca import Rototrans rt = Rototrans . from_random_data () rt_t = Rototrans . from_transposed_rototrans ( rt ) Notes The inverse Rototrans is, by definition, equivalent to the tranposed Rototrans. Source code in pyomeca/rototrans.py @classmethod def from_transposed_rototrans ( cls , rt : xr . DataArray ) -> xr . DataArray : \"\"\" Rototrans DataArray from a tranposed Rototrans. Arguments: rt: Rototrans to transpose Returns: Transposed Rototrans `xarray.DataArray` !!! example ```python from pyomeca import Rototrans rt = Rototrans.from_random_data() rt_t = Rototrans.from_transposed_rototrans(rt) ``` !!! notes The inverse Rototrans is, by definition, equivalent to the tranposed Rototrans. \"\"\" return rototrans . rototrans_from_transposed_rototrans ( cls , rt )","title":"from_transposed_rototrans()"},{"location":"paper/paper/","text":"Statement of Need Biomechanics is defined as the study of the structure and function of biological systems by means of the methods of mechanics [@Hatze1974-zc]. While musculoskeletal biomechanics branches into several subfields, the data used are remarkably similar. The processing, analysis and visualization of these data could therefore be unified in a software package. Most biomechanical data characterizing human and animal movement appear as temporal waveforms representing specific measures such as muscle activity or joint angles. These data are typically multidimensional arrays structured around labels with arbitrary metadata (\\autoref{fig:biomech-data}). Existing software solutions share some limitations. Some of them are proprietary [@Damsgaard2006-gq] or based on closed-source programming language [@Dixon2017-co; @Muller2019-cx]. Others do not leverage labels and metadata [@Walt2011-em; @Hachaj2019-tk; @Virtanen2020-zv]. pyomeca is a Python package designed to address these limitations. It provides basic operations useful in the daily workflow of a biomechanical researcher such as reading, writing, filtering and plotting, but also more advanced biomechanical routines geared towards rigid body mechanics and signal processing. By offering a single, efficient and flexible implementation, pyomeca standardizes these procedures, freeing up valuable research time, thereby allowing researchers to focus on the scientific research questions at hand. Summary As a Python library, pyomeca enables extraction, processing and visualization of biomechanical data for use in research and education. It is motivated by the need for simpler tools and more reproducible workflows allowing practitioners to focus on their specific interests and leaving pyomeca to handle the computational details for them. pyomeca builds on the core scientific Python packages, in particular numpy [@Walt2011-em], scipy [@Virtanen2020-zv], matplotlib [@Hunter2007-fv] and xarray [@Hoyer2017-sf]. By providing labeled querying and computation, efficient algorithms and persistent metadata, the integration of xarray facilitates usability, which seems to be relevant in a context where scientists do not always receive extensive training in programming. xarray is designed as a general-purpose library and tries to avoid including domain specific functionalities --- but inevitably, the need for more domain specific logic arises. pyomeca provides a biomechanics layer that supports specialized file formats ( c3d , mat , trc , sto , mot , csv and xlsx ) and implements signal processing and matrix manipulation routines commonly used in musculoskeletal biomechanics. We believe pyomeca is a solid foundation for more advanced research implementations and could, in the future, provide functions for processing and extracting meaningful clinical outputs from the raw data. pyomeca was written with the Unix philosophy in mind, that is to design each program to do one thing well and expect the output of every program to become the input to another, as yet unknown, program. As such, it is written in a modular, object-oriented way --- which makes it extensible and easy to develop --- and it interacts well with other projects under the pyomeca umbrella , namely ezc3d , pyosim or biorbd-viz . pyomeca follows software best practices by being fully tested, linted and type annotated --- ensuring that the package is easily distributable and modifiable. In addition to the static documentation and API reference , pyomeca includes a set of Jupyter Notebooks with examples. These notebooks can be read and executed by anyone with only a web browser through binder . Features pyomeca inherits from the xarray feature set, which includes label-based indexing, arithmetic, aggregation and alignment, resampling and rolling window operations, plotting, missing data handling and out-of-core computation. In addition, pyomeca has four data structures built upon xarray . Each structure is associated with a specific biomechanical data type: Angles : joint angles, Rototrans : rototranslation matrix, Analogs : generic signals such as electromyographic (EMG) and force signals or any other analog signals, Markers : skin markers positions. While there are technically dozens of functions implemented in pyomeca , one can generally group them into two distinct categories: object creation and data processing. Object Creation The starting point for working with pyomeca is to create an object with one of the specific methods associated with the different classes available. pyomeca offers several ways to create these objects: by directly specifying the data, by sampling random data from distributions, by converting other data structures or by reading files (\\autoref{fig:object-creation}). Data Processing pyomeca 's main functionality is to offer dedicated biomechanical routines. These features can be broadly grouped into different categories: filtering, signal processing, normalization, matrix manipulation and file output functions (\\autoref{fig:data-processing}). A Biomechanical Example: Electromyographic Pipeline pyomeca has documented examples for different biomechanical tasks such as getting Euler angles from a rototranslation matrix, creating a system of axes from skin markers positions or setting a rotation or a translation. Another typical task concerns EMG data processing. Using pyomeca , one can easily extract (\\autoref{fig:ex-1-raw}), process (\\autoref{fig:ex-2-processed}) and visualize (\\autoref{fig:ex-3-aggr}, \\autoref{fig:ex-4-box} and \\autoref{fig:ex-5-corr}) such data. from pyomeca import Analogs emg = Analogs . from_c3d ( \"data.c3d\" ) emg . plot ( x = \"time\" , hue = \"channel\" ) emg_processed = ( emg . meca . band_pass ( order = 2 , cutoff = [ 10 , 425 ]) . meca . center () . meca . abs () . meca . low_pass ( order = 4 , cutoff = 5 ) . meca . normalize () ) emg_processed . plot ( x = \"time\" , col = \"channel\" , col_wrap = 3 ) import matplotlib.pyplot as plt _ , axes = plt . subplots ( ncols = 2 ) emg_processed . mean ( \"channel\" ) . plot ( ax = axes [ 0 ]) emg_processed . plot . hist ( ax = axes [ 1 ], bins = 50 ) emg_dataframe = emg_processed . meca . to_wide_dataframe () emg_dataframe . plot . box ( showfliers = False ) emg_dataframe . corr () . style . background_gradient () . set_precision ( 2 ) Research Projects Using pyomeca You can find an up-to-date list of research projects using pyomeca on the static documentation. Acknowledgements pyomeca is an open-source project created and supported by the Simulation and Movement Modeling (S2M) lab located in Montreal. We thank the contributors that helped build pyomeca . You can find an up-to-date list of contributors on GitHub. We also would like to extend thanks to the contributors of the libraries used to build pyomeca --- particularly numpy [@Walt2011-em], scipy [@Virtanen2020-zv], matplotlib [@Hunter2007-fv] and xarray [@Hoyer2017-sf]. References","title":"`pyomeca`: An Open-Source Framework for Biomechanical Analysis"},{"location":"paper/paper/#statement-of-need","text":"Biomechanics is defined as the study of the structure and function of biological systems by means of the methods of mechanics [@Hatze1974-zc]. While musculoskeletal biomechanics branches into several subfields, the data used are remarkably similar. The processing, analysis and visualization of these data could therefore be unified in a software package. Most biomechanical data characterizing human and animal movement appear as temporal waveforms representing specific measures such as muscle activity or joint angles. These data are typically multidimensional arrays structured around labels with arbitrary metadata (\\autoref{fig:biomech-data}). Existing software solutions share some limitations. Some of them are proprietary [@Damsgaard2006-gq] or based on closed-source programming language [@Dixon2017-co; @Muller2019-cx]. Others do not leverage labels and metadata [@Walt2011-em; @Hachaj2019-tk; @Virtanen2020-zv]. pyomeca is a Python package designed to address these limitations. It provides basic operations useful in the daily workflow of a biomechanical researcher such as reading, writing, filtering and plotting, but also more advanced biomechanical routines geared towards rigid body mechanics and signal processing. By offering a single, efficient and flexible implementation, pyomeca standardizes these procedures, freeing up valuable research time, thereby allowing researchers to focus on the scientific research questions at hand.","title":"Statement of Need"},{"location":"paper/paper/#summary","text":"As a Python library, pyomeca enables extraction, processing and visualization of biomechanical data for use in research and education. It is motivated by the need for simpler tools and more reproducible workflows allowing practitioners to focus on their specific interests and leaving pyomeca to handle the computational details for them. pyomeca builds on the core scientific Python packages, in particular numpy [@Walt2011-em], scipy [@Virtanen2020-zv], matplotlib [@Hunter2007-fv] and xarray [@Hoyer2017-sf]. By providing labeled querying and computation, efficient algorithms and persistent metadata, the integration of xarray facilitates usability, which seems to be relevant in a context where scientists do not always receive extensive training in programming. xarray is designed as a general-purpose library and tries to avoid including domain specific functionalities --- but inevitably, the need for more domain specific logic arises. pyomeca provides a biomechanics layer that supports specialized file formats ( c3d , mat , trc , sto , mot , csv and xlsx ) and implements signal processing and matrix manipulation routines commonly used in musculoskeletal biomechanics. We believe pyomeca is a solid foundation for more advanced research implementations and could, in the future, provide functions for processing and extracting meaningful clinical outputs from the raw data. pyomeca was written with the Unix philosophy in mind, that is to design each program to do one thing well and expect the output of every program to become the input to another, as yet unknown, program. As such, it is written in a modular, object-oriented way --- which makes it extensible and easy to develop --- and it interacts well with other projects under the pyomeca umbrella , namely ezc3d , pyosim or biorbd-viz . pyomeca follows software best practices by being fully tested, linted and type annotated --- ensuring that the package is easily distributable and modifiable. In addition to the static documentation and API reference , pyomeca includes a set of Jupyter Notebooks with examples. These notebooks can be read and executed by anyone with only a web browser through binder .","title":"Summary"},{"location":"paper/paper/#features","text":"pyomeca inherits from the xarray feature set, which includes label-based indexing, arithmetic, aggregation and alignment, resampling and rolling window operations, plotting, missing data handling and out-of-core computation. In addition, pyomeca has four data structures built upon xarray . Each structure is associated with a specific biomechanical data type: Angles : joint angles, Rototrans : rototranslation matrix, Analogs : generic signals such as electromyographic (EMG) and force signals or any other analog signals, Markers : skin markers positions. While there are technically dozens of functions implemented in pyomeca , one can generally group them into two distinct categories: object creation and data processing.","title":"Features"},{"location":"paper/paper/#object-creation","text":"The starting point for working with pyomeca is to create an object with one of the specific methods associated with the different classes available. pyomeca offers several ways to create these objects: by directly specifying the data, by sampling random data from distributions, by converting other data structures or by reading files (\\autoref{fig:object-creation}).","title":"Object Creation"},{"location":"paper/paper/#data-processing","text":"pyomeca 's main functionality is to offer dedicated biomechanical routines. These features can be broadly grouped into different categories: filtering, signal processing, normalization, matrix manipulation and file output functions (\\autoref{fig:data-processing}).","title":"Data Processing"},{"location":"paper/paper/#a-biomechanical-example-electromyographic-pipeline","text":"pyomeca has documented examples for different biomechanical tasks such as getting Euler angles from a rototranslation matrix, creating a system of axes from skin markers positions or setting a rotation or a translation. Another typical task concerns EMG data processing. Using pyomeca , one can easily extract (\\autoref{fig:ex-1-raw}), process (\\autoref{fig:ex-2-processed}) and visualize (\\autoref{fig:ex-3-aggr}, \\autoref{fig:ex-4-box} and \\autoref{fig:ex-5-corr}) such data. from pyomeca import Analogs emg = Analogs . from_c3d ( \"data.c3d\" ) emg . plot ( x = \"time\" , hue = \"channel\" ) emg_processed = ( emg . meca . band_pass ( order = 2 , cutoff = [ 10 , 425 ]) . meca . center () . meca . abs () . meca . low_pass ( order = 4 , cutoff = 5 ) . meca . normalize () ) emg_processed . plot ( x = \"time\" , col = \"channel\" , col_wrap = 3 ) import matplotlib.pyplot as plt _ , axes = plt . subplots ( ncols = 2 ) emg_processed . mean ( \"channel\" ) . plot ( ax = axes [ 0 ]) emg_processed . plot . hist ( ax = axes [ 1 ], bins = 50 ) emg_dataframe = emg_processed . meca . to_wide_dataframe () emg_dataframe . plot . box ( showfliers = False ) emg_dataframe . corr () . style . background_gradient () . set_precision ( 2 )","title":"A Biomechanical Example: Electromyographic Pipeline"},{"location":"paper/paper/#research-projects-using-pyomeca","text":"You can find an up-to-date list of research projects using pyomeca on the static documentation.","title":"Research Projects Using pyomeca"},{"location":"paper/paper/#acknowledgements","text":"pyomeca is an open-source project created and supported by the Simulation and Movement Modeling (S2M) lab located in Montreal. We thank the contributors that helped build pyomeca . You can find an up-to-date list of contributors on GitHub. We also would like to extend thanks to the contributors of the libraries used to build pyomeca --- particularly numpy [@Walt2011-em], scipy [@Virtanen2020-zv], matplotlib [@Hunter2007-fv] and xarray [@Hoyer2017-sf].","title":"Acknowledgements"},{"location":"paper/paper/#references","text":"","title":"References"}]}